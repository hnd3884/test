package com.adventnet.persistence;

import com.adventnet.db.persistence.metadata.PrimaryKeyDefinition;
import com.adventnet.db.persistence.metadata.UniqueKeyDefinition;
import com.adventnet.db.persistence.metadata.ForeignKeyDefinition;
import com.adventnet.db.persistence.metadata.ColumnDefinition;
import com.adventnet.ds.query.AlterTableQuery;
import com.adventnet.ds.query.AlterTableQueryImpl;
import com.adventnet.db.persistence.metadata.IndexDefinition;
import com.adventnet.db.persistence.metadata.util.MetaDataUtil;
import java.util.Iterator;
import java.util.List;
import java.util.Collection;
import java.util.ArrayList;
import com.adventnet.db.persistence.metadata.DataDictionary;
import java.util.logging.Level;
import com.adventnet.db.persistence.metadata.TableDefinition;
import com.adventnet.db.adapter.SQLGenerator;
import java.util.logging.Logger;

public class DataModelUpdateUtil
{
    private static final Logger LOGGER;
    private static int changeNumber;
    private static SQLGenerator sqlGen;
    private static Boolean generateDestructiveChanges;
    
    private static boolean checkForDestructiveChanges(final String message) {
        if (!DataModelUpdateUtil.generateDestructiveChanges) {
            throw new IllegalArgumentException("Destructive changes will not be generated by default. " + message);
        }
        return true;
    }
    
    protected static void initSQLGenerator(final SQLGenerator sqlGenClass) throws Exception {
        DataModelUpdateUtil.sqlGen = sqlGenClass;
    }
    
    private static int getChangeNo() throws Exception {
        return DataModelUpdateUtil.changeNumber++;
    }
    
    private static boolean needToHandleTDChanges(final TableDefinition td) {
        if (td.isTemplate()) {
            DataModelUpdateUtil.LOGGER.log(Level.WARNING, "\n\n****** Ignoring this table :: [{0}] for the diff generation\n\n", td.getTableName());
            return false;
        }
        return true;
    }
    
    public static void generateChangesForDD(final DataDictionary oldDD, final DataDictionary latestDD, final StringBuilder sb) throws Exception {
        if (latestDD == null) {
            throw new IllegalArgumentException("This method generates the diff only for DD addition / modification only. It does not generate SQLs for removal of DD.");
        }
        if (oldDD == null) {
            generateChangesForAddDD(latestDD, sb);
        }
        else {
            final List<TableDefinition> clonedOldTDs = new ArrayList<TableDefinition>(oldDD.getTableDefinitions());
            for (final TableDefinition latestTD : latestDD.getTableDefinitions()) {
                if (needToHandleTDChanges(latestTD)) {
                    final String tableName = latestTD.getTableName();
                    final TableDefinition oldTD = oldDD.getTableDefinitionByName(tableName);
                    if (oldTD == null) {
                        writeChangesToBuffer(latestTD, sb);
                    }
                    else {
                        generateChangesForTD(oldTD, latestTD, sb);
                        clonedOldTDs.remove(oldTD);
                    }
                }
            }
            for (int i = clonedOldTDs.size() - 1; i >= 0; --i) {
                final TableDefinition oldTD2 = clonedOldTDs.get(i);
                final String errorMessage = "Drop table not allowed :: " + oldTD2.getTableName();
                if (needToHandleTDChanges(oldTD2) && checkForDestructiveChanges(errorMessage)) {
                    writeChangesToBuffer(oldTD2.getTableName(), sb);
                }
            }
        }
    }
    
    private static void generateChangesForAddDD(final DataDictionary latestDD, final StringBuilder sb) throws Exception {
        final DataDictionary newDD = new DataDictionary(latestDD.getName());
        MetaDataUtil.addDataDictionaryConfiguration(newDD);
        for (final TableDefinition latestTD : latestDD.getTableDefinitions()) {
            if (needToHandleTDChanges(latestTD)) {
                writeChangesToBuffer(latestTD, sb);
            }
        }
    }
    
    public static void generateChangesForTD(final TableDefinition oldTD, final TableDefinition latestTD, final StringBuilder sb) throws Exception {
        generateChangesForRemoveIndex(oldTD, latestTD, sb);
        generateChangesForRemoveConstraints(oldTD, latestTD, sb);
        generateChangesInColumns(oldTD, latestTD, sb);
        generateChangesForAddConstraints(oldTD, latestTD, sb);
        generateChangesForAddIndex(oldTD, latestTD, sb);
    }
    
    private static void generateChangesForRemoveIndex(final TableDefinition oldTbDef, final TableDefinition latestTbDef, final StringBuilder sb) throws Exception {
        AlterTableQuery atq = null;
        if (oldTbDef.getIndexes() != null) {
            final List<IndexDefinition> oldIdxs = new ArrayList<IndexDefinition>(oldTbDef.getIndexes());
            for (final IndexDefinition oldIdx : oldIdxs) {
                final IndexDefinition latestIdx = latestTbDef.getIndexDefinitionByName(oldIdx.getName());
                if (latestIdx == null || !oldIdx.getColumns().equals(latestIdx.getColumns()) || isIndexModified(oldIdx, latestIdx)) {
                    atq = new AlterTableQueryImpl(oldTbDef.getTableName());
                    atq.dropIndex(oldIdx.getName());
                    writeChangesToBuffer(atq, sb);
                }
            }
        }
    }
    
    private static void generateChangesForAddIndex(final TableDefinition oldTbDef, final TableDefinition latestTbDef, final StringBuilder sb) throws Exception {
        AlterTableQuery atq = null;
        if (latestTbDef.getIndexes() != null) {
            final List<IndexDefinition> latestIdxs = new ArrayList<IndexDefinition>(latestTbDef.getIndexes());
            for (final IndexDefinition latestIdx : latestIdxs) {
                final IndexDefinition oldIdx = oldTbDef.getIndexDefinitionByName(latestIdx.getName());
                if (oldIdx == null || !oldIdx.getColumns().equals(latestIdx.getColumns()) || isIndexModified(oldIdx, latestIdx)) {
                    atq = new AlterTableQueryImpl(oldTbDef.getTableName());
                    atq.addIndex(latestIdx);
                    writeChangesToBuffer(atq, sb);
                }
            }
        }
    }
    
    private static boolean isIndexModified(final IndexDefinition oldIndex, final IndexDefinition newIndex) {
        if (DataModelUpdateUtil.sqlGen.getClass().getName().toLowerCase().contains("mysql")) {
            if (oldIndex.isPartialIndex() != newIndex.isPartialIndex()) {
                return true;
            }
            if (oldIndex.isPartialIndex() && newIndex.isPartialIndex()) {
                for (final String col : oldIndex.getColumns()) {
                    if (newIndex.getSize(col) != oldIndex.getSize(col)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    private static void generateChangesInColumns(final TableDefinition oldTbDef, final TableDefinition latestTbDef, final StringBuilder sb) throws Exception {
        final AlterTableQuery atq = new AlterTableQueryImpl(latestTbDef.getTableName());
        String errorMessage = null;
        for (final Object o : latestTbDef.getColumnList()) {
            final ColumnDefinition latestColDef = (ColumnDefinition)o;
            final String latestColName = latestColDef.getColumnName();
            if (oldTbDef.getColumnDefinitionByName(latestColName) == null) {
                latestColDef.setUnique(false);
                atq.addColumn(latestColDef);
            }
            else {
                final ColumnDefinition oldColDef = oldTbDef.getColumnDefinitionByName(latestColName);
                final String tableName = oldTbDef.getTableName();
                boolean changed = false;
                if (!oldColDef.isUnique() && latestColDef.isUnique()) {
                    latestColDef.setUnique(false);
                }
                errorMessage = "DataType of the column [" + latestColDef.getColumnName() + "] in the table [" + tableName + "] cannot be modified from [" + oldColDef.getDataType() + "] to [" + latestColDef.getDataType() + "] (DataType changes are not allowed)";
                if (!oldColDef.getDataType().equals(latestColDef.getDataType()) && checkForDestructiveChanges(errorMessage)) {
                    sb.append("-- WARNING : Change in data type of the column [" + latestColDef.getColumnName() + "] in the table [" + latestColDef.getTableName() + "] will lead to inconsistent results\n\n");
                    DataModelUpdateUtil.LOGGER.log(Level.INFO, "datatype modified in :: [{0}].[{1}]", new Object[] { tableName, latestColDef.getColumnName() });
                    changed = true;
                }
                errorMessage = "Nullable true cannot be modified as Nullable false for the column '" + oldColDef.getColumnName() + "' in the table '" + tableName + "'";
                if (oldColDef.isNullable() != latestColDef.isNullable()) {
                    if (oldColDef.isNullable() && checkForDestructiveChanges(errorMessage)) {
                        sb.append("-- WARNING : Changing nullable to non nullable for the column " + latestColDef.getColumnName() + " in the table " + latestColDef.getTableName() + " will lead to inconsistent results during data retrieval\n\n");
                    }
                    DataModelUpdateUtil.LOGGER.log(Level.INFO, "nullable modified in :: [{0}].[{1}]", new Object[] { tableName, latestColDef.getColumnName() });
                    changed = true;
                }
                errorMessage = "Maximum length of the column [" + latestColDef.getColumnName() + "] in the table [" + tableName + "] cannot be reduced from [" + oldColDef.getMaxLength() + "] to [" + latestColDef.getMaxLength() + "].";
                if (oldColDef.getMaxLength() != latestColDef.getMaxLength()) {
                    final boolean isLess = latestColDef.getMaxLength() < oldColDef.getMaxLength();
                    if (isLess && checkForDestructiveChanges(errorMessage)) {
                        sb.append("-- WARNING : Reducing the length of the column [" + latestColDef.getColumnName() + "] in the table [" + latestColDef.getTableName() + "] may truncate the data in the table\n\n");
                    }
                    DataModelUpdateUtil.LOGGER.log(Level.INFO, "maxlength modified in :: [{0}].[{1}]", new Object[] { tableName, latestColDef.getColumnName() });
                    changed = true;
                }
                final Object oldDefVal = oldColDef.getDefaultValue();
                final Object latestDefVal = latestColDef.getDefaultValue();
                if ((oldDefVal != null && !oldDefVal.equals(latestDefVal)) || (latestDefVal != null && !latestDefVal.equals(oldDefVal))) {
                    DataModelUpdateUtil.LOGGER.log(Level.INFO, "default value modified in :: [{0}].[{1}]", new Object[] { tableName, latestColDef.getColumnName() });
                    changed = true;
                }
                if (!changed) {
                    continue;
                }
                atq.modifyColumn(oldColDef.getColumnName(), latestColDef);
            }
        }
        for (final Object o : oldTbDef.getColumnList()) {
            final ColumnDefinition oldColDef2 = (ColumnDefinition)o;
            if (latestTbDef.getColumnDefinitionByName(oldColDef2.getColumnName()) == null) {
                errorMessage = "Drop column is not allowed :: " + oldColDef2.getColumnName();
                if (!checkForDestructiveChanges(errorMessage)) {
                    continue;
                }
                atq.removeColumn(oldColDef2.getColumnName());
            }
        }
        if (atq.getAlterOperations().size() > 0) {
            writeChangesToBuffer(atq, sb);
        }
    }
    
    private static void generateChangesForRemoveConstraints(final TableDefinition oldTbDef, final TableDefinition latestTbDef, final StringBuilder sb) throws Exception {
        final AlterTableQuery atq = new AlterTableQueryImpl(latestTbDef.getTableName());
        final PrimaryKeyDefinition oldPK = oldTbDef.getPrimaryKey();
        final PrimaryKeyDefinition latestPK = latestTbDef.getPrimaryKey();
        if (!oldPK.getName().equals(latestPK.getName()) || !isEquals(oldPK.getColumnList(), latestPK.getColumnList())) {
            atq.removePrimaryKey(oldPK.getName());
        }
        for (final Object o : oldTbDef.getForeignKeyList()) {
            final ForeignKeyDefinition oldFkDef = (ForeignKeyDefinition)o;
            final String fkName = oldFkDef.getName();
            final ForeignKeyDefinition latestFkDef = latestTbDef.getForeignKeyDefinitionByName(fkName);
            if (latestFkDef == null || !oldFkDef.getMasterTableName().equals(latestFkDef.getMasterTableName()) || oldFkDef.getConstraints() != latestFkDef.getConstraints() || !isEquals(oldFkDef.getFkColumns(), latestFkDef.getFkColumns()) || !isEquals(oldFkDef.getFkRefColumns(), latestFkDef.getFkRefColumns())) {
                atq.removeForeignKey(fkName);
            }
        }
        if (oldTbDef.getUniqueKeys() != null) {
            for (final UniqueKeyDefinition oldUkDef : oldTbDef.getUniqueKeys()) {
                final UniqueKeyDefinition latestUkDef = latestTbDef.getUniqueKeyDefinitionByName(oldUkDef.getName());
                if (latestUkDef == null || !isEquals(oldUkDef.getColumns(), latestUkDef.getColumns())) {
                    atq.removeUniqueKey(oldUkDef.getName());
                }
            }
        }
        if (atq.getAlterOperations().size() > 0) {
            writeChangesToBuffer(atq, sb);
        }
    }
    
    private static boolean isEquals(final List list1, final List list2) {
        return list1.containsAll(list2) && list2.containsAll(list1);
    }
    
    private static void generateChangesForAddConstraints(final TableDefinition oldTbDef, final TableDefinition latestTbDef, final StringBuilder sb) throws Exception {
        final AlterTableQuery atq = new AlterTableQueryImpl(latestTbDef.getTableName());
        final PrimaryKeyDefinition oldPK = oldTbDef.getPrimaryKey();
        final PrimaryKeyDefinition latestPK = latestTbDef.getPrimaryKey();
        if (!oldPK.getName().equals(latestPK.getName()) || !isEquals(oldPK.getColumnList(), latestPK.getColumnList())) {
            atq.addPrimaryKey(latestPK);
        }
        if (latestTbDef.getUniqueKeys() != null) {
            for (final UniqueKeyDefinition latestUkDef : latestTbDef.getUniqueKeys()) {
                final UniqueKeyDefinition oldUkDef = oldTbDef.getUniqueKeyDefinitionByName(latestUkDef.getName());
                if (oldUkDef == null) {
                    atq.addUniqueKey(latestUkDef);
                }
            }
        }
        for (final Object o : latestTbDef.getForeignKeyList()) {
            final ForeignKeyDefinition latestFkDef = (ForeignKeyDefinition)o;
            final ForeignKeyDefinition oldFkDef = oldTbDef.getForeignKeyDefinitionByName(latestFkDef.getName());
            if (oldFkDef == null) {
                atq.addForeignKey(latestFkDef);
            }
        }
        if (atq.getAlterOperations().size() > 0) {
            writeChangesToBuffer(atq, sb);
        }
    }
    
    private static void appendSQLs(final StringBuilder sb, final Object installSQL, final String revertSQL) throws Exception {
        if (Boolean.getBoolean("generate.preinstall.sqls")) {
            sb.append("\nPREINSTALL - $ ");
            sb.append(revertSQL);
        }
        if (installSQL instanceof String) {
            sb.append("\n\nINSTALL    - $ ");
            sb.append(installSQL);
        }
        else {
            final List<String> sqls = (List<String>)installSQL;
            for (final String sql : sqls) {
                sb.append("\n\nINSTALL    - $ ");
                sb.append(sql);
            }
        }
        sb.append("\n\nREVERT     - $ ");
        sb.append(revertSQL);
        sb.append("\n\n");
        sb.append("--INFO :: The given sleep value should be in milliseconds... \n\n SLEEP\t     - $ ");
        sb.append(0);
        sb.append("\n\n-- End of Change :: " + getChangeNo() + " \n\n\n");
    }
    
    private static boolean writeChangesToBuffer(final Object installObj, final StringBuilder sb) throws Exception {
        if (installObj != null) {
            if (installObj instanceof AlterTableQuery) {
                final AlterTableQuery atq = (AlterTableQuery)installObj;
                final String installSQL = DataModelUpdateUtil.sqlGen.getSQLForAlterTable(atq);
                if (atq.getAlterOperations().size() == 0) {
                    return false;
                }
                atq.setRevertFlag(true);
                final String revertSQL = DataModelUpdateUtil.sqlGen.getSQLForAlterTable(atq);
                appendSQLs(sb, installSQL, revertSQL);
                MetaDataUtil.alterTableDefinition(atq);
            }
            else if (installObj instanceof TableDefinition) {
                final TableDefinition td = (TableDefinition)installObj;
                final List<String> installSQLs = new ArrayList<String>();
                installSQLs.add(DataModelUpdateUtil.sqlGen.getSQLForCreateTable(td));
                final String revertSQL = DataModelUpdateUtil.sqlGen.getSQLForDrop(td.getTableName(), false);
                appendSQLs(sb, installSQLs, revertSQL);
                if (td.getIndexes() != null) {
                    for (final IndexDefinition idxDef : td.getIndexes()) {
                        appendSQLs(sb, DataModelUpdateUtil.sqlGen.getSQLForIndex(td.getTableName(), idxDef), DataModelUpdateUtil.sqlGen.getSQLForDropIndex(td.getTableName(), idxDef.getName()));
                    }
                }
                MetaDataUtil.addTableDefinition(td.getModuleName(), td);
            }
            else {
                if (!(installObj instanceof String)) {
                    throw new IllegalArgumentException("Unknown object type found in installQueries");
                }
                final String tableName = (String)installObj;
                final String installSQL = DataModelUpdateUtil.sqlGen.getSQLForDrop(tableName, false);
                final TableDefinition td2 = MetaDataUtil.getTableDefinitionByName(tableName);
                if (td2.getIndexes() != null) {
                    for (final IndexDefinition idxDef : td2.getIndexes()) {
                        appendSQLs(sb, DataModelUpdateUtil.sqlGen.getSQLForDropIndex(td2.getTableName(), idxDef.getName()), DataModelUpdateUtil.sqlGen.getSQLForIndex(td2.getTableName(), idxDef));
                    }
                }
                final String revertSQL2 = DataModelUpdateUtil.sqlGen.getSQLForCreateTable(td2);
                appendSQLs(sb, installSQL, revertSQL2);
                MetaDataUtil.removeTableDefinition(tableName);
            }
            return true;
        }
        return false;
    }
    
    static {
        LOGGER = Logger.getLogger(DataModelUpdateUtil.class.getName());
        DataModelUpdateUtil.changeNumber = 1;
        DataModelUpdateUtil.sqlGen = null;
        DataModelUpdateUtil.generateDestructiveChanges = Boolean.getBoolean("generate.destructive.changes");
    }
}
