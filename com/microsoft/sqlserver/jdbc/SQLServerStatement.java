package com.microsoft.sqlserver.jdbc;

import java.sql.Connection;
import java.sql.BatchUpdateException;
import java.text.MessageFormat;
import java.util.StringTokenizer;
import java.sql.SQLException;
import java.util.logging.Level;
import java.sql.SQLTimeoutException;
import java.sql.SQLWarning;
import java.util.Vector;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.ArrayList;
import java.sql.ResultSet;
import java.util.logging.Logger;

public class SQLServerStatement implements ISQLServerStatement
{
    private static final long serialVersionUID = -4421134713913331507L;
    static final char LEFT_CURLY_BRACKET = '{';
    static final char RIGHT_CURLY_BRACKET = '}';
    private boolean isResponseBufferingAdaptive;
    private boolean wasResponseBufferingSet;
    static final String identityQuery = " select SCOPE_IDENTITY() AS GENERATED_KEYS";
    String procedureName;
    private int serverCursorId;
    private int serverCursorRowCount;
    boolean stmtPoolable;
    private TDSReader tdsReader;
    Parameter[] inOutParam;
    final SQLServerConnection connection;
    int queryTimeout;
    int cancelQueryTimeoutSeconds;
    boolean isCloseOnCompletion;
    private volatile TDSCommand currentCommand;
    private TDSCommand lastStmtExecCmd;
    static final Logger loggerExternal;
    private final String loggingClassName;
    private final String traceID;
    protected SQLServerStatementColumnEncryptionSetting stmtColumnEncriptionSetting;
    private ExecuteProperties execProps;
    boolean moreResults;
    SQLServerResultSet resultSet;
    int resultSetCount;
    static final int EXECUTE_NOT_SET = 0;
    static final int EXECUTE_QUERY = 1;
    static final int EXECUTE_UPDATE = 2;
    static final int EXECUTE = 3;
    static final int EXECUTE_BATCH = 4;
    static final int EXECUTE_QUERY_INTERNAL = 5;
    int executeMethod;
    long updateCount;
    boolean escapeProcessing;
    int maxRows;
    int maxFieldSize;
    int resultSetConcurrency;
    int appResultSetType;
    int resultSetType;
    boolean executedSqlDirectly;
    boolean expectCursorOutParams;
    String cursorName;
    int nFetchSize;
    int defaultFetchSize;
    int nFetchDirection;
    boolean bIsClosed;
    boolean bRequestedGeneratedKeys;
    private ResultSet autoGeneratedKeys;
    private final ArrayList<String> batchStatementBuffer;
    private static final Logger stmtlogger;
    private static final AtomicInteger lastStatementID;
    Vector<SQLWarning> sqlWarnings;
    boolean isInternalEncryptionQuery;
    
    final boolean getIsResponseBufferingAdaptive() {
        return this.isResponseBufferingAdaptive;
    }
    
    final boolean wasResponseBufferingSet() {
        return this.wasResponseBufferingSet;
    }
    
    final int getServerCursorId() {
        return this.serverCursorId;
    }
    
    final int getServerCursorRowCount() {
        return this.serverCursorRowCount;
    }
    
    final TDSReader resultsReader() {
        return this.tdsReader;
    }
    
    final boolean wasExecuted() {
        return null != this.tdsReader;
    }
    
    final void discardLastExecutionResults() {
        if (null != this.lastStmtExecCmd && !this.bIsClosed) {
            this.lastStmtExecCmd.close();
            this.lastStmtExecCmd = null;
        }
        this.clearLastResult();
    }
    
    String getClassNameLogging() {
        return this.loggingClassName;
    }
    
    protected SQLServerStatementColumnEncryptionSetting getStmtColumnEncriptionSetting() {
        return this.stmtColumnEncriptionSetting;
    }
    
    final ExecuteProperties getExecProps() {
        return this.execProps;
    }
    
    final void executeStatement(final TDSCommand newStmtCmd) throws SQLServerException, SQLTimeoutException {
        this.discardLastExecutionResults();
        this.checkClosed();
        this.execProps = new ExecuteProperties(this);
        try {
            this.executeCommand(newStmtCmd);
        }
        catch (final SQLServerException e) {
            if (e.getDriverErrorCode() == 9) {
                throw new SQLTimeoutException(e.getMessage(), e.getSQLState(), e.getErrorCode(), e.getCause());
            }
            throw e;
        }
        finally {
            this.lastStmtExecCmd = newStmtCmd;
        }
    }
    
    final void executeCommand(final TDSCommand newCommand) throws SQLServerException {
        this.currentCommand = newCommand;
        this.connection.executeCommand(newCommand);
    }
    
    synchronized void incrResultSetCount() {
        ++this.resultSetCount;
    }
    
    synchronized void decrResultSetCount() {
        --this.resultSetCount;
        assert this.resultSetCount >= 0;
        if (this.isCloseOnCompletion && (4 != this.executeMethod || !this.moreResults) && this.resultSetCount == 0) {
            this.closeInternal();
        }
    }
    
    final int getSQLResultSetType() {
        return this.resultSetType;
    }
    
    final int getCursorType() {
        return this.getResultSetScrollOpt() & 0xFFFFEFFF;
    }
    
    final boolean isCursorable(final int executeMethod) {
        return this.resultSetType != 2003 && (3 == executeMethod || 1 == executeMethod);
    }
    
    @Override
    public String toString() {
        return this.traceID;
    }
    
    String getClassNameInternal() {
        return "SQLServerStatement";
    }
    
    private static int nextStatementID() {
        return SQLServerStatement.lastStatementID.incrementAndGet();
    }
    
    SQLServerStatement(final SQLServerConnection con, final int nType, final int nConcur, final SQLServerStatementColumnEncryptionSetting stmtColEncSetting) throws SQLServerException {
        this.isResponseBufferingAdaptive = false;
        this.wasResponseBufferingSet = false;
        this.isCloseOnCompletion = false;
        this.currentCommand = null;
        this.lastStmtExecCmd = null;
        this.stmtColumnEncriptionSetting = SQLServerStatementColumnEncryptionSetting.UseConnectionSetting;
        this.moreResults = false;
        this.resultSetCount = 0;
        this.executeMethod = 0;
        this.updateCount = -1L;
        this.maxRows = 0;
        this.maxFieldSize = 0;
        this.executedSqlDirectly = false;
        this.batchStatementBuffer = new ArrayList<String>();
        final int statementID = nextStatementID();
        final String classN = this.getClassNameInternal();
        this.traceID = classN + ":" + statementID;
        this.loggingClassName = "com.microsoft.sqlserver.jdbc." + classN + ":" + statementID;
        this.stmtPoolable = false;
        this.connection = con;
        this.bIsClosed = false;
        if (1003 != nType && 1005 != nType && 1004 != nType && 2003 != nType && 2004 != nType && 1006 != nType && 1005 != nType && 1004 != nType) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_unsupportedCursor"), null, true);
        }
        if (1007 != nConcur && 1008 != nConcur && 1009 != nConcur && 1008 != nConcur && 1010 != nConcur) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_unsupportedConcurrency"), null, true);
        }
        if (null == stmtColEncSetting) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_unsupportedStmtColEncSetting"), null, true);
        }
        this.stmtColumnEncriptionSetting = stmtColEncSetting;
        this.resultSetConcurrency = nConcur;
        if (1003 == (this.appResultSetType = nType)) {
            if (1007 == nConcur) {
                final String selectMethod = con.getSelectMethod();
                this.resultSetType = ((null == selectMethod || !"cursor".equals(selectMethod)) ? 2003 : 2004);
            }
            else {
                this.resultSetType = 2004;
            }
        }
        else if (1004 == nType) {
            this.resultSetType = 1004;
        }
        else if (1005 == nType) {
            this.resultSetType = 1005;
        }
        else {
            this.resultSetType = nType;
        }
        this.nFetchDirection = ((2003 == this.resultSetType || 2004 == this.resultSetType) ? 1000 : 1002);
        this.nFetchSize = ((1009 == this.resultSetConcurrency) ? 8 : 128);
        this.defaultFetchSize = this.nFetchSize;
        if (1007 != nConcur && (2003 == this.resultSetType || 1004 == this.resultSetType)) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_unsupportedCursorAndConcurrency"), null, true);
        }
        this.setResponseBuffering(this.connection.getResponseBuffering());
        this.setDefaultQueryTimeout();
        this.setDefaultQueryCancelTimeout();
        if (SQLServerStatement.stmtlogger.isLoggable(Level.FINER)) {
            SQLServerStatement.stmtlogger.finer("Properties for " + this.toString() + ": Result type:" + this.appResultSetType + " (" + this.resultSetType + ") Concurrency:" + this.resultSetConcurrency + " Fetchsize:" + this.nFetchSize + " bIsClosed:" + this.bIsClosed + " useLastUpdateCount:" + this.connection.useLastUpdateCount());
        }
        if (SQLServerStatement.stmtlogger.isLoggable(Level.FINE)) {
            SQLServerStatement.stmtlogger.fine(this.toString() + " created by (" + this.connection.toString() + ")");
        }
    }
    
    private void setDefaultQueryCancelTimeout() {
        final int cancelQueryTimeoutSeconds = this.connection.getCancelQueryTimeoutSeconds();
        if (cancelQueryTimeoutSeconds > 0) {
            this.cancelQueryTimeoutSeconds = cancelQueryTimeoutSeconds;
        }
    }
    
    private void setDefaultQueryTimeout() {
        final int queryTimeoutSeconds = this.connection.getQueryTimeoutSeconds();
        if (queryTimeoutSeconds > 0) {
            this.queryTimeout = queryTimeoutSeconds;
        }
    }
    
    final Logger getStatementLogger() {
        return SQLServerStatement.stmtlogger;
    }
    
    void closeInternal() {
        assert !this.bIsClosed;
        this.discardLastExecutionResults();
        this.bIsClosed = true;
        this.autoGeneratedKeys = null;
        this.sqlWarnings = null;
        this.inOutParam = null;
        this.connection.removeOpenStatement(this);
    }
    
    @Override
    public void close() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "close");
        if (!this.bIsClosed) {
            this.closeInternal();
        }
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "close");
    }
    
    @Override
    public void closeOnCompletion() throws SQLException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "closeOnCompletion");
        this.checkClosed();
        this.isCloseOnCompletion = true;
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "closeOnCompletion");
    }
    
    @Override
    public ResultSet executeQuery(final String sql) throws SQLServerException, SQLTimeoutException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "executeQuery", sql);
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            SQLServerStatement.loggerExternal.finer(this.toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        this.checkClosed();
        this.executeStatement(new StmtExecCmd(this, sql, 1, 2));
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "executeQuery", this.resultSet);
        return this.resultSet;
    }
    
    final SQLServerResultSet executeQueryInternal(final String sql) throws SQLServerException, SQLTimeoutException {
        this.checkClosed();
        this.executeStatement(new StmtExecCmd(this, sql, 5, 2));
        return this.resultSet;
    }
    
    @Override
    public int executeUpdate(final String sql) throws SQLServerException, SQLTimeoutException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "executeUpdate", sql);
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            SQLServerStatement.loggerExternal.finer(this.toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        this.checkClosed();
        this.executeStatement(new StmtExecCmd(this, sql, 2, 2));
        if (this.updateCount < -2147483648L || this.updateCount > 2147483647L) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_updateCountOutofRange"), null, true);
        }
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "executeUpdate", this.updateCount);
        return (int)this.updateCount;
    }
    
    @Override
    public long executeLargeUpdate(final String sql) throws SQLServerException, SQLTimeoutException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "executeLargeUpdate", sql);
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            SQLServerStatement.loggerExternal.finer(this.toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        this.checkClosed();
        this.executeStatement(new StmtExecCmd(this, sql, 2, 2));
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "executeLargeUpdate", this.updateCount);
        return this.updateCount;
    }
    
    @Override
    public boolean execute(final String sql) throws SQLServerException, SQLTimeoutException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "execute", sql);
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            SQLServerStatement.loggerExternal.finer(this.toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        this.checkClosed();
        this.executeStatement(new StmtExecCmd(this, sql, 3, 2));
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "execute", null != this.resultSet);
        return null != this.resultSet;
    }
    
    private String ensureSQLSyntax(final String sql) throws SQLServerException {
        if (sql.indexOf(123) >= 0) {
            final SQLServerConnection.CityHash128Key cacheKey = new SQLServerConnection.CityHash128Key(sql);
            ParsedSQLCacheItem cacheItem = SQLServerConnection.getCachedParsedSQL(cacheKey);
            if (null == cacheItem) {
                cacheItem = SQLServerConnection.parseAndCacheSQL(cacheKey, sql);
            }
            this.procedureName = cacheItem.procedureName;
            return cacheItem.processedSQL;
        }
        return sql;
    }
    
    void startResults() {
        this.moreResults = true;
    }
    
    final void setMaxRowsAndMaxFieldSize() throws SQLServerException {
        if (1 == this.executeMethod || 3 == this.executeMethod) {
            this.connection.setMaxRows(this.maxRows);
            this.connection.setMaxFieldSize(this.maxFieldSize);
        }
        else {
            assert 5 == this.executeMethod;
            this.connection.setMaxRows(0);
        }
    }
    
    final void doExecuteStatement(final StmtExecCmd execCmd) throws SQLServerException {
        this.resetForReexecute();
        this.executeMethod = execCmd.executeMethod;
        final String sql = this.ensureSQLSyntax(execCmd.sql);
        if (!this.isInternalEncryptionQuery && this.connection.isAEv2()) {
            execCmd.enclaveCEKs = this.connection.initEnclaveParameters(sql, null, null, null);
        }
        this.setMaxRowsAndMaxFieldSize();
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            SQLServerStatement.loggerExternal.finer(this.toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        if (this.isCursorable(this.executeMethod) && this.isSelect(sql)) {
            if (SQLServerStatement.stmtlogger.isLoggable(Level.FINE)) {
                SQLServerStatement.stmtlogger.fine(this.toString() + " Executing server side cursor " + sql);
            }
            this.doExecuteCursored(execCmd, sql);
        }
        else {
            this.executedSqlDirectly = true;
            this.expectCursorOutParams = false;
            final TDSWriter tdsWriter = execCmd.startRequest((byte)1);
            tdsWriter.sendEnclavePackage(sql, execCmd.enclaveCEKs);
            tdsWriter.writeString(sql);
            if (1 == execCmd.autoGeneratedKeys && (2 == this.executeMethod || 3 == this.executeMethod) && sql.trim().toUpperCase().startsWith("INSERT")) {
                tdsWriter.writeString(" select SCOPE_IDENTITY() AS GENERATED_KEYS");
            }
            if (SQLServerStatement.stmtlogger.isLoggable(Level.FINE)) {
                SQLServerStatement.stmtlogger.fine(this.toString() + " Executing (not server cursor) " + sql);
            }
            this.ensureExecuteResultsReader(execCmd.startResponse(this.isResponseBufferingAdaptive));
            this.startResults();
            this.getNextResult(true);
        }
        if (null == this.resultSet) {
            if (1 == this.executeMethod) {
                SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_noResultset"), null, true);
            }
        }
        else if (2 == this.executeMethod || 4 == this.executeMethod) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_resultsetGeneratedForUpdate"), null, false);
        }
    }
    
    private void doExecuteStatementBatch(final StmtBatchExecCmd execCmd) throws SQLServerException {
        this.resetForReexecute();
        this.connection.setMaxRows(0);
        final String batchStatementString = String.join(";", this.batchStatementBuffer);
        if (this.connection.isAEv2()) {
            execCmd.enclaveCEKs = this.connection.initEnclaveParameters(batchStatementString, null, null, null);
        }
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            SQLServerStatement.loggerExternal.finer(this.toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        this.executeMethod = 4;
        this.executedSqlDirectly = true;
        this.expectCursorOutParams = false;
        final TDSWriter tdsWriter = execCmd.startRequest((byte)1);
        tdsWriter.sendEnclavePackage(batchStatementString, execCmd.enclaveCEKs);
        tdsWriter.writeString(batchStatementString);
        this.ensureExecuteResultsReader(execCmd.startResponse(this.isResponseBufferingAdaptive));
        this.startResults();
        this.getNextResult(true);
        if (null != this.resultSet) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_resultsetGeneratedForUpdate"), null, false);
        }
    }
    
    final void resetForReexecute() throws SQLServerException {
        this.ensureExecuteResultsReader(null);
        this.autoGeneratedKeys = null;
        this.updateCount = -1L;
        this.sqlWarnings = null;
        this.executedSqlDirectly = false;
        this.startResults();
    }
    
    final boolean isSelect(final String sql) throws SQLServerException {
        this.checkClosed();
        final String temp = sql.trim();
        return null != sql && sql.length() >= 6 && "select".equalsIgnoreCase(temp.substring(0, 6));
    }
    
    final boolean isInsert(final String sql) throws SQLServerException {
        this.checkClosed();
        final String temp = sql.trim();
        if (null == sql || sql.length() < 6) {
            return false;
        }
        if ("/*".equalsIgnoreCase(temp.substring(0, 2))) {
            final int index = temp.indexOf("*/") + 2;
            return this.isInsert(temp.substring(index));
        }
        return "insert".equalsIgnoreCase(temp.substring(0, 6));
    }
    
    static String replaceParameterWithString(String str, final char marker, final String replaceStr) {
        for (int index = 0; (index = str.indexOf("" + marker)) >= 0; str = str.substring(0, index) + replaceStr + str.substring(index + 1, str.length())) {}
        return str;
    }
    
    static String replaceMarkerWithNull(final String sql) {
        if (!sql.contains("'")) {
            return replaceParameterWithString(sql, '?', "null");
        }
        final StringTokenizer st = new StringTokenizer(sql, "'", true);
        boolean beforeColon = true;
        final StringBuilder retSql = new StringBuilder();
        while (st.hasMoreTokens()) {
            final String str = st.nextToken();
            if ("'".equals(str)) {
                retSql.append("'");
                beforeColon = !beforeColon;
            }
            else if (beforeColon) {
                final String repStr = replaceParameterWithString(str, '?', "null");
                retSql.append(repStr);
            }
            else {
                retSql.append(str);
            }
        }
        return retSql.toString();
    }
    
    void checkClosed() throws SQLServerException {
        this.connection.checkClosed();
        if (this.bIsClosed) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_statementIsClosed"), null, false);
        }
    }
    
    @Override
    public final int getMaxFieldSize() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getMaxFieldSize");
        this.checkClosed();
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getMaxFieldSize", this.maxFieldSize);
        return this.maxFieldSize;
    }
    
    @Override
    public final void setMaxFieldSize(final int max) throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "setMaxFieldSize", max);
        this.checkClosed();
        if (max < 0) {
            final MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidLength"));
            final Object[] msgArgs = { max };
            SQLServerException.makeFromDriverError(this.connection, this, form.format(msgArgs), null, true);
        }
        this.maxFieldSize = max;
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "setMaxFieldSize");
    }
    
    @Override
    public final int getMaxRows() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getMaxRows");
        this.checkClosed();
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getMaxRows", this.maxRows);
        return this.maxRows;
    }
    
    @Override
    public final long getLargeMaxRows() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getLargeMaxRows");
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getLargeMaxRows", (long)this.maxRows);
        return this.getMaxRows();
    }
    
    @Override
    public final void setMaxRows(final int max) throws SQLServerException {
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER)) {
            SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "setMaxRows", max);
        }
        this.checkClosed();
        if (max < 0) {
            final MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidRowcount"));
            final Object[] msgArgs = { max };
            SQLServerException.makeFromDriverError(this.connection, this, form.format(msgArgs), null, true);
        }
        if (1006 != this.resultSetType) {
            this.maxRows = max;
        }
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "setMaxRows");
    }
    
    @Override
    public final void setLargeMaxRows(final long max) throws SQLServerException {
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER)) {
            SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "setLargeMaxRows", max);
        }
        if (max > 2147483647L) {
            final MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidMaxRows"));
            final Object[] msgArgs = { max };
            SQLServerException.makeFromDriverError(this.connection, this, form.format(msgArgs), null, true);
        }
        this.setMaxRows((int)max);
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "setLargeMaxRows");
    }
    
    @Override
    public final void setEscapeProcessing(final boolean enable) throws SQLServerException {
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER)) {
            SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "setEscapeProcessing", enable);
        }
        this.checkClosed();
        this.escapeProcessing = enable;
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "setEscapeProcessing");
    }
    
    @Override
    public final int getQueryTimeout() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getQueryTimeout");
        this.checkClosed();
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getQueryTimeout", this.queryTimeout);
        return this.queryTimeout;
    }
    
    @Override
    public final void setQueryTimeout(final int seconds) throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "setQueryTimeout", seconds);
        this.checkClosed();
        if (seconds < 0) {
            final MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidQueryTimeOutValue"));
            final Object[] msgArgs = { seconds };
            SQLServerException.makeFromDriverError(this.connection, this, form.format(msgArgs), null, true);
        }
        this.queryTimeout = seconds;
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "setQueryTimeout");
    }
    
    @Override
    public final int getCancelQueryTimeout() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getCancelQueryTimeout");
        this.checkClosed();
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getCancelQueryTimeout", this.cancelQueryTimeoutSeconds);
        return this.cancelQueryTimeoutSeconds;
    }
    
    @Override
    public final void setCancelQueryTimeout(final int seconds) throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "setCancelQueryTimeout", seconds);
        this.checkClosed();
        if (seconds < 0) {
            final MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidCancelQueryTimeout"));
            final Object[] msgArgs = { seconds };
            SQLServerException.makeFromDriverError(this.connection, this, form.format(msgArgs), null, true);
        }
        this.cancelQueryTimeoutSeconds = seconds;
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "setCancelQueryTimeout");
    }
    
    @Override
    public final void cancel() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "cancel");
        this.checkClosed();
        if (null != this.currentCommand) {
            this.currentCommand.interrupt(SQLServerException.getErrString("R_queryCancelled"));
        }
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "cancel");
    }
    
    @Override
    public final SQLWarning getWarnings() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getWarnings");
        this.checkClosed();
        if (this.sqlWarnings == null) {
            return null;
        }
        final SQLWarning warn = this.sqlWarnings.elementAt(0);
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getWarnings", warn);
        return warn;
    }
    
    @Override
    public final void clearWarnings() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "clearWarnings");
        this.checkClosed();
        this.sqlWarnings = null;
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "clearWarnings");
    }
    
    @Override
    public final void setCursorName(final String name) throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "setCursorName", name);
        this.checkClosed();
        this.cursorName = name;
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "setCursorName");
    }
    
    final String getCursorName() {
        return this.cursorName;
    }
    
    @Override
    public final ResultSet getResultSet() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getResultSet");
        this.checkClosed();
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getResultSet", this.resultSet);
        return this.resultSet;
    }
    
    @Override
    public final int getUpdateCount() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getUpdateCount");
        this.checkClosed();
        if (this.updateCount < -2147483648L || this.updateCount > 2147483647L) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_updateCountOutofRange"), null, true);
        }
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getUpdateCount", this.updateCount);
        return (int)this.updateCount;
    }
    
    @Override
    public final long getLargeUpdateCount() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getUpdateCount");
        this.checkClosed();
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getUpdateCount", this.updateCount);
        return this.updateCount;
    }
    
    final void ensureExecuteResultsReader(final TDSReader tdsReader) {
        this.tdsReader = tdsReader;
    }
    
    final void processExecuteResults() throws SQLServerException {
        if (this.wasExecuted()) {
            this.processBatch();
            TDSParser.parse(this.resultsReader(), "batch completion");
            this.ensureExecuteResultsReader(null);
        }
    }
    
    void processBatch() throws SQLServerException {
        this.processResults();
    }
    
    final void processResults() throws SQLServerException {
        SQLServerException interruptException = null;
        while (this.moreResults) {
            try {
                this.getNextResult(true);
                continue;
            }
            catch (final SQLServerException e) {
                if (this.moreResults) {
                    if (2 == e.getDriverErrorCode()) {
                        if (!SQLServerStatement.stmtlogger.isLoggable(Level.FINEST)) {
                            continue;
                        }
                        SQLServerStatement.stmtlogger.finest(this + " ignoring database error: " + e.getErrorCode() + " " + e.getMessage());
                        continue;
                    }
                    if (e.getSQLState() != null && e.getSQLState().equals(SQLState.STATEMENT_CANCELED.getSQLStateCode())) {
                        interruptException = e;
                        continue;
                    }
                }
                this.moreResults = false;
                throw e;
            }
            break;
        }
        this.clearLastResult();
        if (null != interruptException) {
            throw interruptException;
        }
    }
    
    @Override
    public final boolean getMoreResults() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getMoreResults");
        this.checkClosed();
        this.getNextResult(true);
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getMoreResults", null != this.resultSet);
        return null != this.resultSet;
    }
    
    final void clearLastResult() {
        this.updateCount = -1L;
        if (null != this.resultSet) {
            try {
                this.resultSet.close();
            }
            catch (final SQLServerException e) {
                SQLServerStatement.stmtlogger.finest(this + " clearing last result; ignored error closing ResultSet: " + e.getErrorCode() + " " + e.getMessage());
            }
            finally {
                this.resultSet = null;
            }
        }
    }
    
    final boolean getNextResult(final boolean clearFlag) throws SQLServerException {
        if (!this.wasExecuted()) {
            return this.moreResults = false;
        }
        if (clearFlag) {
            this.clearLastResult();
        }
        if (!this.moreResults) {
            return false;
        }
        final class NextResult extends TDSTokenHandler
        {
            private StreamDone stmtDoneToken;
            private boolean isResultSet;
            private StreamRetStatus procedureRetStatToken;
            
            final boolean isUpdateCount() {
                return null != this.stmtDoneToken;
            }
            
            final long getUpdateCount() {
                return this.stmtDoneToken.getUpdateCount();
            }
            
            final boolean isResultSet() {
                return this.isResultSet;
            }
            
            NextResult() {
                super("getNextResult");
                this.stmtDoneToken = null;
                this.isResultSet = false;
                this.procedureRetStatToken = null;
            }
            
            @Override
            boolean onColMetaData(final TDSReader tdsReader) throws SQLServerException {
                if (null == this.stmtDoneToken && null == this.getDatabaseError()) {
                    this.isResultSet = true;
                }
                return false;
            }
            
            @Override
            boolean onDone(final TDSReader tdsReader) throws SQLServerException {
                final StreamDone doneToken = new StreamDone();
                doneToken.setFromTDS(tdsReader);
                if (doneToken.isAttnAck()) {
                    return false;
                }
                if (doneToken.cmdIsDMLOrDDL()) {
                    if (-1L == doneToken.getUpdateCount() && 4 != SQLServerStatement.this.executeMethod) {
                        return true;
                    }
                    if (-1L != doneToken.getUpdateCount() && 1 == SQLServerStatement.this.executeMethod) {
                        return true;
                    }
                    this.stmtDoneToken = doneToken;
                    if (255 != doneToken.getTokenType()) {
                        return false;
                    }
                    if (4 != SQLServerStatement.this.executeMethod) {
                        if (null != SQLServerStatement.this.procedureName) {
                            return false;
                        }
                        if (3 == SQLServerStatement.this.executeMethod) {
                            return false;
                        }
                        if (!SQLServerStatement.this.connection.useLastUpdateCount()) {
                            return false;
                        }
                    }
                }
                else {
                    if (doneToken.isFinal()) {
                        return SQLServerStatement.this.moreResults = false;
                    }
                    if (4 == SQLServerStatement.this.executeMethod && (255 != doneToken.getTokenType() || doneToken.wasRPCInBatch())) {
                        return SQLServerStatement.this.moreResults = false;
                    }
                }
                return !doneToken.isError();
            }
            
            @Override
            boolean onRetStatus(final TDSReader tdsReader) throws SQLServerException {
                if (SQLServerStatement.this.consumeExecOutParam(tdsReader)) {
                    SQLServerStatement.this.moreResults = false;
                }
                else {
                    (this.procedureRetStatToken = new StreamRetStatus()).setFromTDS(tdsReader);
                }
                return true;
            }
            
            @Override
            boolean onRetValue(final TDSReader tdsReader) throws SQLServerException {
                if (SQLServerStatement.this.moreResults && null == this.procedureRetStatToken) {
                    final Parameter p = new Parameter(Util.shouldHonorAEForParameters(SQLServerStatement.this.stmtColumnEncriptionSetting, SQLServerStatement.this.connection));
                    p.skipRetValStatus(tdsReader);
                    p.skipValue(tdsReader, true);
                    return true;
                }
                return false;
            }
            
            @Override
            boolean onInfo(final TDSReader tdsReader) throws SQLServerException {
                final StreamInfo infoToken = new StreamInfo();
                infoToken.setFromTDS(tdsReader);
                if (16954 == infoToken.msg.getErrorNumber()) {
                    SQLServerStatement.this.executedSqlDirectly = true;
                }
                final SQLWarning warning = new SQLWarning(infoToken.msg.getErrorMessage(), SQLServerException.generateStateCode(SQLServerStatement.this.connection, infoToken.msg.getErrorNumber(), infoToken.msg.getErrorState()), infoToken.msg.getErrorNumber());
                if (SQLServerStatement.this.sqlWarnings == null) {
                    SQLServerStatement.this.sqlWarnings = new Vector<SQLWarning>();
                }
                else {
                    final int n = SQLServerStatement.this.sqlWarnings.size();
                    final SQLWarning w = SQLServerStatement.this.sqlWarnings.elementAt(n - 1);
                    w.setNextWarning(warning);
                }
                SQLServerStatement.this.sqlWarnings.add(warning);
                return true;
            }
        }
        final NextResult nextResult = new NextResult();
        TDSParser.parse(this.resultsReader(), nextResult, !clearFlag);
        if (null != nextResult.getDatabaseError()) {
            SQLServerException.makeFromDatabaseError(this.connection, null, nextResult.getDatabaseError().getErrorMessage(), nextResult.getDatabaseError(), false);
        }
        if (!clearFlag) {
            return false;
        }
        if (nextResult.isResultSet()) {
            this.resultSet = new SQLServerResultSet(this);
            return true;
        }
        if (nextResult.isUpdateCount()) {
            this.updateCount = nextResult.getUpdateCount();
            return true;
        }
        this.updateCount = -1L;
        return !this.moreResults || (this.moreResults = false);
    }
    
    boolean consumeExecOutParam(final TDSReader tdsReader) throws SQLServerException {
        if (this.expectCursorOutParams) {
            TDSParser.parse(tdsReader, new StmtExecOutParamHandler());
            return true;
        }
        return false;
    }
    
    @Override
    public final void setFetchDirection(final int nDir) throws SQLServerException {
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER)) {
            SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "setFetchDirection", nDir);
        }
        this.checkClosed();
        if ((1000 != nDir && 1001 != nDir && 1002 != nDir) || (1000 != nDir && (2003 == this.resultSetType || 2004 == this.resultSetType))) {
            final MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidFetchDirection"));
            final Object[] msgArgs = { nDir };
            SQLServerException.makeFromDriverError(this.connection, this, form.format(msgArgs), null, false);
        }
        this.nFetchDirection = nDir;
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "setFetchDirection");
    }
    
    @Override
    public final int getFetchDirection() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getFetchDirection");
        this.checkClosed();
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getFetchDirection", this.nFetchDirection);
        return this.nFetchDirection;
    }
    
    @Override
    public final void setFetchSize(final int rows) throws SQLServerException {
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER)) {
            SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "setFetchSize", rows);
        }
        this.checkClosed();
        if (rows < 0) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_invalidFetchSize"), null, false);
        }
        this.nFetchSize = ((0 == rows) ? this.defaultFetchSize : rows);
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "setFetchSize");
    }
    
    @Override
    public final int getFetchSize() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getFetchSize");
        this.checkClosed();
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getFetchSize", this.nFetchSize);
        return this.nFetchSize;
    }
    
    @Override
    public final int getResultSetConcurrency() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getResultSetConcurrency");
        this.checkClosed();
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getResultSetConcurrency", this.resultSetConcurrency);
        return this.resultSetConcurrency;
    }
    
    @Override
    public final int getResultSetType() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getResultSetType");
        this.checkClosed();
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getResultSetType", this.appResultSetType);
        return this.appResultSetType;
    }
    
    @Override
    public void addBatch(String sql) throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "addBatch", sql);
        this.checkClosed();
        sql = this.ensureSQLSyntax(sql);
        this.batchStatementBuffer.add(sql);
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "addBatch");
    }
    
    @Override
    public void clearBatch() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "clearBatch");
        this.checkClosed();
        this.batchStatementBuffer.clear();
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "clearBatch");
    }
    
    @Override
    public int[] executeBatch() throws SQLServerException, BatchUpdateException, SQLTimeoutException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "executeBatch");
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            SQLServerStatement.loggerExternal.finer(this.toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        this.checkClosed();
        this.discardLastExecutionResults();
        try {
            final int batchSize = this.batchStatementBuffer.size();
            final int[] updateCounts = new int[batchSize];
            for (int batchNum = 0; batchNum < batchSize; ++batchNum) {
                updateCounts[batchNum] = -3;
            }
            SQLServerException lastError = null;
            for (int batchNum2 = 0; batchNum2 < batchSize; ++batchNum2) {
                try {
                    if (0 == batchNum2) {
                        this.executeStatement(new StmtBatchExecCmd(this));
                    }
                    else {
                        this.startResults();
                        if (!this.getNextResult(true)) {
                            break;
                        }
                    }
                    if (null != this.resultSet) {
                        SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_resultsetGeneratedForUpdate"), null, true);
                    }
                    else {
                        updateCounts[batchNum2] = ((-1 != (int)this.updateCount) ? ((int)this.updateCount) : -2);
                    }
                }
                catch (final SQLServerException e) {
                    if (this.connection.isSessionUnAvailable() || this.connection.rolledBackTransaction()) {
                        throw e;
                    }
                    lastError = e;
                }
            }
            if (null != lastError) {
                throw new BatchUpdateException(lastError.getMessage(), lastError.getSQLState(), lastError.getErrorCode(), updateCounts);
            }
            SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "executeBatch", updateCounts);
            return updateCounts;
        }
        finally {
            this.batchStatementBuffer.clear();
        }
    }
    
    @Override
    public long[] executeLargeBatch() throws SQLServerException, BatchUpdateException, SQLTimeoutException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "executeLargeBatch");
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            SQLServerStatement.loggerExternal.finer(this.toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        this.checkClosed();
        this.discardLastExecutionResults();
        try {
            final int batchSize = this.batchStatementBuffer.size();
            final long[] updateCounts = new long[batchSize];
            for (int batchNum = 0; batchNum < batchSize; ++batchNum) {
                updateCounts[batchNum] = -3L;
            }
            SQLServerException lastError = null;
            for (int batchNum2 = 0; batchNum2 < batchSize; ++batchNum2) {
                try {
                    if (0 == batchNum2) {
                        this.executeStatement(new StmtBatchExecCmd(this));
                    }
                    else {
                        this.startResults();
                        if (!this.getNextResult(true)) {
                            break;
                        }
                    }
                    if (null != this.resultSet) {
                        SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_resultsetGeneratedForUpdate"), null, true);
                    }
                    else {
                        updateCounts[batchNum2] = ((-1L != this.updateCount) ? this.updateCount : -2L);
                    }
                }
                catch (final SQLServerException e) {
                    if (this.connection.isSessionUnAvailable() || this.connection.rolledBackTransaction()) {
                        throw e;
                    }
                    lastError = e;
                }
            }
            if (null != lastError) {
                DriverJDBCVersion.throwBatchUpdateException(lastError, updateCounts);
            }
            SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "executeLargeBatch", updateCounts);
            return updateCounts;
        }
        finally {
            this.batchStatementBuffer.clear();
        }
    }
    
    @Override
    public final Connection getConnection() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getConnection");
        if (this.bIsClosed) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_statementIsClosed"), null, false);
        }
        final Connection con = this.connection.getConnection();
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getConnection", con);
        return con;
    }
    
    final int getResultSetScrollOpt() {
        final int scrollOpt = (null == this.inOutParam) ? 0 : 4096;
        switch (this.resultSetType) {
            case 2004: {
                return scrollOpt | ((1007 == this.resultSetConcurrency) ? 16 : 4);
            }
            case 1006: {
                return scrollOpt | 0x2;
            }
            case 1005: {
                return scrollOpt | 0x1;
            }
            case 1004: {
                return scrollOpt | 0x8;
            }
            default: {
                return 0;
            }
        }
    }
    
    final int getResultSetCCOpt() {
        switch (this.resultSetConcurrency) {
            case 1007: {
                return 8193;
            }
            case 1008: {
                return 24580;
            }
            case 1009: {
                return 24578;
            }
            case 1010: {
                return 24584;
            }
            default: {
                return 0;
            }
        }
    }
    
    private void doExecuteCursored(final StmtExecCmd execCmd, final String sql) throws SQLServerException {
        if (SQLServerStatement.stmtlogger.isLoggable(Level.FINER)) {
            SQLServerStatement.stmtlogger.finer(this.toString() + " Execute for cursor open SQL:" + sql + " Scrollability:" + this.getResultSetScrollOpt() + " Concurrency:" + this.getResultSetCCOpt());
        }
        this.executedSqlDirectly = false;
        this.expectCursorOutParams = true;
        final TDSWriter tdsWriter = execCmd.startRequest((byte)3);
        tdsWriter.writeShort((short)(-1));
        tdsWriter.writeShort((short)2);
        tdsWriter.writeByte((byte)0);
        tdsWriter.writeByte((byte)0);
        tdsWriter.sendEnclavePackage(sql, execCmd.enclaveCEKs);
        tdsWriter.writeRPCInt(null, 0, true);
        tdsWriter.writeRPCStringUnicode(sql);
        tdsWriter.writeRPCInt(null, this.getResultSetScrollOpt(), false);
        tdsWriter.writeRPCInt(null, this.getResultSetCCOpt(), false);
        tdsWriter.writeRPCInt(null, 0, true);
        this.ensureExecuteResultsReader(execCmd.startResponse(this.isResponseBufferingAdaptive));
        this.startResults();
        this.getNextResult(true);
    }
    
    @Override
    public final int getResultSetHoldability() throws SQLException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getResultSetHoldability");
        this.checkClosed();
        final int holdability = this.connection.getHoldability();
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getResultSetHoldability", holdability);
        return holdability;
    }
    
    @Override
    public final boolean execute(final String sql, final int autoGeneratedKeys) throws SQLServerException, SQLTimeoutException {
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER)) {
            SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "execute", new Object[] { sql, autoGeneratedKeys });
            if (Util.isActivityTraceOn()) {
                SQLServerStatement.loggerExternal.finer(this.toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
            }
        }
        this.checkClosed();
        if (autoGeneratedKeys != 1 && autoGeneratedKeys != 2) {
            final MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidAutoGeneratedKeys"));
            final Object[] msgArgs = { autoGeneratedKeys };
            SQLServerException.makeFromDriverError(this.connection, this, form.format(msgArgs), null, false);
        }
        this.executeStatement(new StmtExecCmd(this, sql, 3, autoGeneratedKeys));
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "execute", null != this.resultSet);
        return null != this.resultSet;
    }
    
    @Override
    public final boolean execute(final String sql, final int[] columnIndexes) throws SQLServerException, SQLTimeoutException {
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER)) {
            SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "execute", new Object[] { sql, columnIndexes });
        }
        this.checkClosed();
        if (columnIndexes == null || columnIndexes.length != 1) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_invalidColumnArrayLength"), null, false);
        }
        final boolean fSuccess = this.execute(sql, 1);
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "execute", fSuccess);
        return fSuccess;
    }
    
    @Override
    public final boolean execute(final String sql, final String[] columnNames) throws SQLServerException, SQLTimeoutException {
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER)) {
            SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "execute", new Object[] { sql, columnNames });
        }
        this.checkClosed();
        if (columnNames == null || columnNames.length != 1) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_invalidColumnArrayLength"), null, false);
        }
        final boolean fSuccess = this.execute(sql, 1);
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "execute", fSuccess);
        return fSuccess;
    }
    
    @Override
    public final int executeUpdate(final String sql, final int autoGeneratedKeys) throws SQLServerException, SQLTimeoutException {
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER)) {
            SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "executeUpdate", new Object[] { sql, autoGeneratedKeys });
            if (Util.isActivityTraceOn()) {
                SQLServerStatement.loggerExternal.finer(this.toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
            }
        }
        this.checkClosed();
        if (autoGeneratedKeys != 1 && autoGeneratedKeys != 2) {
            final MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidAutoGeneratedKeys"));
            final Object[] msgArgs = { autoGeneratedKeys };
            SQLServerException.makeFromDriverError(this.connection, this, form.format(msgArgs), null, false);
        }
        this.executeStatement(new StmtExecCmd(this, sql, 2, autoGeneratedKeys));
        if (this.updateCount < -2147483648L || this.updateCount > 2147483647L) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_updateCountOutofRange"), null, true);
        }
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "executeUpdate", this.updateCount);
        return (int)this.updateCount;
    }
    
    @Override
    public final long executeLargeUpdate(final String sql, final int autoGeneratedKeys) throws SQLServerException, SQLTimeoutException {
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER)) {
            SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "executeLargeUpdate", new Object[] { sql, autoGeneratedKeys });
            if (Util.isActivityTraceOn()) {
                SQLServerStatement.loggerExternal.finer(this.toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
            }
        }
        this.checkClosed();
        if (autoGeneratedKeys != 1 && autoGeneratedKeys != 2) {
            final MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidAutoGeneratedKeys"));
            final Object[] msgArgs = { autoGeneratedKeys };
            SQLServerException.makeFromDriverError(this.connection, this, form.format(msgArgs), null, false);
        }
        this.executeStatement(new StmtExecCmd(this, sql, 2, autoGeneratedKeys));
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "executeLargeUpdate", this.updateCount);
        return this.updateCount;
    }
    
    @Override
    public final int executeUpdate(final String sql, final int[] columnIndexes) throws SQLServerException, SQLTimeoutException {
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER)) {
            SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "executeUpdate", new Object[] { sql, columnIndexes });
        }
        this.checkClosed();
        if (columnIndexes == null || columnIndexes.length != 1) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_invalidColumnArrayLength"), null, false);
        }
        final int count = this.executeUpdate(sql, 1);
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "executeUpdate", count);
        return count;
    }
    
    @Override
    public final long executeLargeUpdate(final String sql, final int[] columnIndexes) throws SQLServerException, SQLTimeoutException {
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER)) {
            SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "executeLargeUpdate", new Object[] { sql, columnIndexes });
        }
        this.checkClosed();
        if (columnIndexes == null || columnIndexes.length != 1) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_invalidColumnArrayLength"), null, false);
        }
        final long count = this.executeLargeUpdate(sql, 1);
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "executeLargeUpdate", count);
        return count;
    }
    
    @Override
    public final int executeUpdate(final String sql, final String[] columnNames) throws SQLServerException, SQLTimeoutException {
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER)) {
            SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "executeUpdate", new Object[] { sql, columnNames });
        }
        this.checkClosed();
        if (columnNames == null || columnNames.length != 1) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_invalidColumnArrayLength"), null, false);
        }
        final int count = this.executeUpdate(sql, 1);
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "executeUpdate", count);
        return count;
    }
    
    @Override
    public final long executeLargeUpdate(final String sql, final String[] columnNames) throws SQLServerException, SQLTimeoutException {
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER)) {
            SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "executeLargeUpdate", new Object[] { sql, columnNames });
        }
        this.checkClosed();
        if (columnNames == null || columnNames.length != 1) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_invalidColumnArrayLength"), null, false);
        }
        final long count = this.executeLargeUpdate(sql, 1);
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "executeLargeUpdate", count);
        return count;
    }
    
    @Override
    public final ResultSet getGeneratedKeys() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getGeneratedKeys");
        this.checkClosed();
        if (null == this.autoGeneratedKeys) {
            final long orgUpd = this.updateCount;
            if (!this.getNextResult(true) || null == this.resultSet) {
                SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_statementMustBeExecuted"), null, false);
            }
            this.autoGeneratedKeys = this.resultSet;
            this.updateCount = orgUpd;
        }
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getGeneratedKeys", this.autoGeneratedKeys);
        return this.autoGeneratedKeys;
    }
    
    @Override
    public final boolean getMoreResults(final int mode) throws SQLException {
        if (SQLServerStatement.loggerExternal.isLoggable(Level.FINER)) {
            SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getMoreResults", mode);
        }
        this.checkClosed();
        if (2 == mode) {
            SQLServerException.throwNotSupportedException(this.connection, this);
        }
        if (1 != mode && 3 != mode) {
            SQLServerException.makeFromDriverError(this.connection, this, SQLServerException.getErrString("R_modeSuppliedNotValid"), null, true);
        }
        final ResultSet rsPrevious = this.resultSet;
        final boolean fResults = this.getMoreResults();
        if (rsPrevious != null) {
            try {
                rsPrevious.close();
            }
            catch (final SQLException e) {
                throw new SQLServerException(e.getMessage(), null, 0, e);
            }
        }
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getMoreResults", fResults);
        return fResults;
    }
    
    @Override
    public boolean isClosed() throws SQLException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "isClosed");
        final boolean result = this.bIsClosed || this.connection.isSessionUnAvailable();
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "isClosed", result);
        return result;
    }
    
    @Override
    public boolean isCloseOnCompletion() throws SQLException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "isCloseOnCompletion");
        this.checkClosed();
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "isCloseOnCompletion", this.isCloseOnCompletion);
        return this.isCloseOnCompletion;
    }
    
    @Override
    public boolean isPoolable() throws SQLException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "isPoolable");
        this.checkClosed();
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "isPoolable", this.stmtPoolable);
        return this.stmtPoolable;
    }
    
    @Override
    public void setPoolable(final boolean poolable) throws SQLException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "setPoolable", poolable);
        this.checkClosed();
        this.stmtPoolable = poolable;
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "setPoolable");
    }
    
    @Override
    public boolean isWrapperFor(final Class<?> iface) throws SQLException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "isWrapperFor");
        final boolean f = iface.isInstance(this);
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "isWrapperFor", f);
        return f;
    }
    
    @Override
    public <T> T unwrap(final Class<T> iface) throws SQLException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "unwrap");
        T t;
        try {
            t = iface.cast(this);
        }
        catch (final ClassCastException e) {
            throw new SQLServerException(e.getMessage(), e);
        }
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "unwrap", t);
        return t;
    }
    
    @Override
    public final void setResponseBuffering(final String value) throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "setResponseBuffering", value);
        this.checkClosed();
        if ("full".equalsIgnoreCase(value)) {
            this.isResponseBufferingAdaptive = false;
            this.wasResponseBufferingSet = true;
        }
        else if ("adaptive".equalsIgnoreCase(value)) {
            this.isResponseBufferingAdaptive = true;
            this.wasResponseBufferingSet = true;
        }
        else {
            final MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidresponseBuffering"));
            final Object[] msgArgs = { value };
            SQLServerException.makeFromDriverError(this.connection, this, form.format(msgArgs), null, false);
        }
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "setResponseBuffering");
    }
    
    @Override
    public final String getResponseBuffering() throws SQLServerException {
        SQLServerStatement.loggerExternal.entering(this.getClassNameLogging(), "getResponseBuffering");
        this.checkClosed();
        String responseBuff;
        if (this.wasResponseBufferingSet) {
            if (this.isResponseBufferingAdaptive) {
                responseBuff = "adaptive";
            }
            else {
                responseBuff = "full";
            }
        }
        else {
            responseBuff = this.connection.getResponseBuffering();
        }
        SQLServerStatement.loggerExternal.exiting(this.getClassNameLogging(), "getResponseBuffering", responseBuff);
        return responseBuff;
    }
    
    static {
        loggerExternal = Logger.getLogger("com.microsoft.sqlserver.jdbc.Statement");
        stmtlogger = Logger.getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerStatement");
        lastStatementID = new AtomicInteger(0);
    }
    
    final class ExecuteProperties
    {
        private final boolean wasResponseBufferingSet;
        private final boolean isResponseBufferingAdaptive;
        private final int holdability;
        
        final boolean wasResponseBufferingSet() {
            return this.wasResponseBufferingSet;
        }
        
        final boolean isResponseBufferingAdaptive() {
            return this.isResponseBufferingAdaptive;
        }
        
        final int getHoldability() {
            return this.holdability;
        }
        
        ExecuteProperties(final SQLServerStatement stmt) {
            this.wasResponseBufferingSet = stmt.wasResponseBufferingSet();
            this.isResponseBufferingAdaptive = stmt.getIsResponseBufferingAdaptive();
            this.holdability = stmt.connection.getHoldabilityInternal();
        }
    }
    
    class StmtExecOutParamHandler extends TDSTokenHandler
    {
        StmtExecOutParamHandler() {
            super("StmtExecOutParamHandler");
        }
        
        @Override
        boolean onRetStatus(final TDSReader tdsReader) throws SQLServerException {
            new StreamRetStatus().setFromTDS(tdsReader);
            return true;
        }
        
        @Override
        boolean onRetValue(final TDSReader tdsReader) throws SQLServerException {
            if (SQLServerStatement.this.expectCursorOutParams) {
                Parameter param = new Parameter(Util.shouldHonorAEForParameters(SQLServerStatement.this.stmtColumnEncriptionSetting, SQLServerStatement.this.connection));
                param.skipRetValStatus(tdsReader);
                SQLServerStatement.this.serverCursorId = param.getInt(tdsReader);
                param.skipValue(tdsReader, true);
                param = new Parameter(Util.shouldHonorAEForParameters(SQLServerStatement.this.stmtColumnEncriptionSetting, SQLServerStatement.this.connection));
                param.skipRetValStatus(tdsReader);
                if (-1 == (SQLServerStatement.this.serverCursorRowCount = param.getInt(tdsReader))) {
                    SQLServerStatement.this.serverCursorRowCount = -3;
                }
                param.skipValue(tdsReader, true);
                SQLServerStatement.this.expectCursorOutParams = false;
                return true;
            }
            return false;
        }
        
        @Override
        boolean onDone(final TDSReader tdsReader) throws SQLServerException {
            return false;
        }
    }
    
    private final class StmtExecCmd extends TDSCommand
    {
        private static final long serialVersionUID = 4534132352812876292L;
        final SQLServerStatement stmt;
        final String sql;
        final int executeMethod;
        final int autoGeneratedKeys;
        
        StmtExecCmd(final SQLServerStatement stmt, final String sql, final int executeMethod, final int autoGeneratedKeys) {
            super(stmt.toString() + " executeXXX", stmt.queryTimeout, stmt.cancelQueryTimeoutSeconds);
            this.stmt = stmt;
            this.sql = sql;
            this.executeMethod = executeMethod;
            this.autoGeneratedKeys = autoGeneratedKeys;
        }
        
        @Override
        final boolean doExecute() throws SQLServerException {
            this.stmt.doExecuteStatement(this);
            return false;
        }
        
        @Override
        final void processResponse(final TDSReader tdsReader) throws SQLServerException {
            SQLServerStatement.this.ensureExecuteResultsReader(tdsReader);
            SQLServerStatement.this.processExecuteResults();
        }
    }
    
    private final class StmtBatchExecCmd extends TDSCommand
    {
        private static final long serialVersionUID = -4621631860790243331L;
        final SQLServerStatement stmt;
        
        StmtBatchExecCmd(final SQLServerStatement stmt) {
            super(stmt.toString() + " executeBatch", stmt.queryTimeout, stmt.cancelQueryTimeoutSeconds);
            this.stmt = stmt;
        }
        
        @Override
        final boolean doExecute() throws SQLServerException {
            this.stmt.doExecuteStatementBatch(this);
            return false;
        }
        
        @Override
        final void processResponse(final TDSReader tdsReader) throws SQLServerException {
            SQLServerStatement.this.ensureExecuteResultsReader(tdsReader);
            SQLServerStatement.this.processExecuteResults();
        }
    }
}
