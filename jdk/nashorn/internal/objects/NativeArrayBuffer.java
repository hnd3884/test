package jdk.nashorn.internal.objects;

import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import jdk.nashorn.internal.runtime.Property;
import java.util.Collection;
import java.lang.invoke.MethodHandle;
import jdk.nashorn.internal.runtime.AccessorProperty;
import java.util.ArrayList;
import jdk.nashorn.internal.runtime.ScriptRuntime;
import jdk.nashorn.internal.runtime.JSType;
import jdk.nashorn.internal.runtime.ECMAErrors;
import jdk.nashorn.internal.runtime.PropertyMap;
import java.nio.ByteBuffer;
import jdk.nashorn.internal.runtime.ScriptObject;

public final class NativeArrayBuffer extends ScriptObject
{
    private final ByteBuffer nb;
    private static PropertyMap $nasgenmap$;
    
    protected NativeArrayBuffer(final ByteBuffer nb, final Global global) {
        super(global.getArrayBufferPrototype(), NativeArrayBuffer.$nasgenmap$);
        this.nb = nb;
    }
    
    protected NativeArrayBuffer(final ByteBuffer nb) {
        this(nb, Global.instance());
    }
    
    protected NativeArrayBuffer(final int byteLength) {
        this(ByteBuffer.allocateDirect(byteLength));
    }
    
    protected NativeArrayBuffer(final NativeArrayBuffer other, final int begin, final int end) {
        this(cloneBuffer(other.getNioBuffer(), begin, end));
    }
    
    public static NativeArrayBuffer constructor(final boolean newObj, final Object self, final Object... args) {
        if (!newObj) {
            throw ECMAErrors.typeError("constructor.requires.new", "ArrayBuffer");
        }
        if (args.length == 0) {
            return new NativeArrayBuffer(0);
        }
        return new NativeArrayBuffer(JSType.toInt32(args[0]));
    }
    
    private static ByteBuffer cloneBuffer(final ByteBuffer original, final int begin, final int end) {
        final ByteBuffer clone = ByteBuffer.allocateDirect(original.capacity());
        original.rewind();
        clone.put(original);
        original.rewind();
        clone.flip();
        clone.position(begin);
        clone.limit(end);
        return clone.slice();
    }
    
    ByteBuffer getNioBuffer() {
        return this.nb;
    }
    
    @Override
    public String getClassName() {
        return "ArrayBuffer";
    }
    
    public static int byteLength(final Object self) {
        return ((NativeArrayBuffer)self).getByteLength();
    }
    
    public static boolean isView(final Object self, final Object obj) {
        return obj instanceof ArrayBufferView;
    }
    
    public static NativeArrayBuffer slice(final Object self, final Object begin0, final Object end0) {
        final NativeArrayBuffer arrayBuffer = (NativeArrayBuffer)self;
        final int byteLength = arrayBuffer.getByteLength();
        final int begin = adjustIndex(JSType.toInt32(begin0), byteLength);
        final int end = adjustIndex((end0 != ScriptRuntime.UNDEFINED) ? JSType.toInt32(end0) : byteLength, byteLength);
        return new NativeArrayBuffer(arrayBuffer, begin, Math.max(end, begin));
    }
    
    public static Object slice(final Object self, final int begin, final int end) {
        final NativeArrayBuffer arrayBuffer = (NativeArrayBuffer)self;
        final int byteLength = arrayBuffer.getByteLength();
        return new NativeArrayBuffer(arrayBuffer, adjustIndex(begin, byteLength), Math.max(adjustIndex(end, byteLength), begin));
    }
    
    public static Object slice(final Object self, final int begin) {
        return slice(self, begin, ((NativeArrayBuffer)self).getByteLength());
    }
    
    static int adjustIndex(final int index, final int length) {
        return (index < 0) ? clamp(index + length, length) : clamp(index, length);
    }
    
    private static int clamp(final int index, final int length) {
        if (index < 0) {
            return 0;
        }
        if (index > length) {
            return length;
        }
        return index;
    }
    
    int getByteLength() {
        return this.nb.limit();
    }
    
    ByteBuffer getBuffer() {
        return this.nb;
    }
    
    ByteBuffer getBuffer(final int offset) {
        return (ByteBuffer)this.nb.duplicate().position(offset);
    }
    
    ByteBuffer getBuffer(final int offset, final int length) {
        return (ByteBuffer)this.getBuffer(offset).limit(length);
    }
    
    static {
        $clinit$();
    }
    
    public static void $clinit$() {
        final ArrayList properties = new ArrayList(1);
        properties.add(AccessorProperty.create("byteLength", 7, /* ldc_method_handle(!) */ProcyonConstantHelper_27.HANDLE, (MethodHandle)null));
        NativeArrayBuffer.$nasgenmap$ = PropertyMap.newMap(properties);
    }
    
    private static final MethodHandles.Lookup __PROCYON__LOOKUP_27__ = MethodHandles.lookup();
    
    // This helper class was generated by Procyon to approximate the behavior of a
    // MethodHandle constant that cannot (currently) be represented in Java code.
    private static final class ProcyonConstantHelper_27
    {
        static final MethodHandle HANDLE;
        
        static {
            MethodHandle handle;
            final MethodType type = MethodType.methodType(int.class, Object.class);
            try {
                handle = NativeArrayBuffer.__PROCYON__LOOKUP_27__.findStatic(NativeArrayBuffer.class, "byteLength", type);
            }
            catch (final ReflectiveOperationException e) {
                handle = MethodHandles.permuteArguments(MethodHandles.insertArguments(MethodHandles.throwException(type.returnType(), e.getClass()), 0, e), type);
            }
            ProcyonConstantHelper_27.HANDLE = handle;
        }
    }
}
