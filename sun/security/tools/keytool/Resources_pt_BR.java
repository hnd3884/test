package sun.security.tools.keytool;

import java.util.ListResourceBundle;

public class Resources_pt_BR extends ListResourceBundle
{
    private static final Object[][] contents;
    
    public Object[][] getContents() {
        return Resources_pt_BR.contents;
    }
    
    static {
        contents = new Object[][] { { "NEWLINE", "\n" }, { "STAR", "*******************************************" }, { "STARNN", "*******************************************\n\n" }, { ".OPTION.", " [OPTION]..." }, { "Options.", "Op\u00e7\u00f5es:" }, { "Use.keytool.help.for.all.available.commands", "Use \"keytool -help\" para todos os comandos dispon\u00edveis" }, { "Key.and.Certificate.Management.Tool", "Ferramenta de Gerenciamento de Chave e Certificado" }, { "Commands.", "Comandos:" }, { "Use.keytool.command.name.help.for.usage.of.command.name", "Use \"keytool -command_name -help\" para uso de command_name" }, { "Generates.a.certificate.request", "Gera uma solicita\u00e7\u00e3o de certificado" }, { "Changes.an.entry.s.alias", "Altera um alias de entrada" }, { "Deletes.an.entry", "Exclui uma entrada" }, { "Exports.certificate", "Exporta o certificado" }, { "Generates.a.key.pair", "Gera um par de chaves" }, { "Generates.a.secret.key", "Gera uma chave secreta" }, { "Generates.certificate.from.a.certificate.request", "Gera um certificado de uma solicita\u00e7\u00e3o de certificado" }, { "Generates.CRL", "Gera CRL" }, { "Generated.keyAlgName.secret.key", "Chave secreta {0} gerada" }, { "Generated.keysize.bit.keyAlgName.secret.key", "Chave secreta {1} de {0} bits gerada" }, { "Imports.entries.from.a.JDK.1.1.x.style.identity.database", "Importa entradas de um banco de dados de identidade JDK 1.1.x-style" }, { "Imports.a.certificate.or.a.certificate.chain", "Importa um certificado ou uma cadeia de certificados" }, { "Imports.a.password", "Importa uma senha" }, { "Imports.one.or.all.entries.from.another.keystore", "Importa uma ou todas as entradas de outra \u00e1rea de armazenamento de chaves" }, { "Clones.a.key.entry", "Clona uma entrada de chave" }, { "Changes.the.key.password.of.an.entry", "Altera a senha da chave de uma entrada" }, { "Lists.entries.in.a.keystore", "Lista entradas em uma \u00e1rea de armazenamento de chaves" }, { "Prints.the.content.of.a.certificate", "Imprime o conte\u00fado de um certificado" }, { "Prints.the.content.of.a.certificate.request", "Imprime o conte\u00fado de uma solicita\u00e7\u00e3o de certificado" }, { "Prints.the.content.of.a.CRL.file", "Imprime o conte\u00fado de um arquivo CRL" }, { "Generates.a.self.signed.certificate", "Gera um certificado autoassinado" }, { "Changes.the.store.password.of.a.keystore", "Altera a senha de armazenamento de uma \u00e1rea de armazenamento de chaves" }, { "alias.name.of.the.entry.to.process", "nome do alias da entrada a ser processada" }, { "destination.alias", "alias de destino" }, { "destination.key.password", "senha da chave de destino" }, { "destination.keystore.name", "nome da \u00e1rea de armazenamento de chaves de destino" }, { "destination.keystore.password.protected", "senha protegida da \u00e1rea de armazenamento de chaves de destino" }, { "destination.keystore.provider.name", "nome do fornecedor da \u00e1rea de armazenamento de chaves de destino" }, { "destination.keystore.password", "senha da \u00e1rea de armazenamento de chaves de destino" }, { "destination.keystore.type", "tipo de \u00e1rea de armazenamento de chaves de destino" }, { "distinguished.name", "nome distinto" }, { "X.509.extension", "extens\u00e3o X.509" }, { "output.file.name", "nome do arquivo de sa\u00edda" }, { "input.file.name", "nome do arquivo de entrada" }, { "key.algorithm.name", "nome do algoritmo da chave" }, { "key.password", "senha da chave" }, { "key.bit.size", "tamanho do bit da chave" }, { "keystore.name", "nome da \u00e1rea de armazenamento de chaves" }, { "new.password", "nova senha" }, { "do.not.prompt", "n\u00e3o perguntar" }, { "password.through.protected.mechanism", "senha por meio de mecanismo protegido" }, { "provider.argument", "argumento do fornecedor" }, { "provider.class.name", "nome da classe do fornecedor" }, { "provider.name", "nome do fornecedor" }, { "provider.classpath", "classpath do fornecedor" }, { "output.in.RFC.style", "sa\u00edda no estilo RFC" }, { "signature.algorithm.name", "nome do algoritmo de assinatura" }, { "source.alias", "alias de origem" }, { "source.key.password", "senha da chave de origem" }, { "source.keystore.name", "nome da \u00e1rea de armazenamento de chaves de origem" }, { "source.keystore.password.protected", "senha protegida da \u00e1rea de armazenamento de chaves de origem" }, { "source.keystore.provider.name", "nome do fornecedor da \u00e1rea de armazenamento de chaves de origem" }, { "source.keystore.password", "senha da \u00e1rea de armazenamento de chaves de origem" }, { "source.keystore.type", "tipo de \u00e1rea de armazenamento de chaves de origem" }, { "SSL.server.host.and.port", "porta e host do servidor SSL" }, { "signed.jar.file", "arquivo jar assinado" }, { "certificate.validity.start.date.time", "data/hora inicial de validade do certificado" }, { "keystore.password", "senha da \u00e1rea de armazenamento de chaves" }, { "keystore.type", "tipo de \u00e1rea de armazenamento de chaves" }, { "trust.certificates.from.cacerts", "certificados confi\u00e1veis do cacerts" }, { "verbose.output", "sa\u00edda detalhada" }, { "validity.number.of.days", "n\u00famero de dias da validade" }, { "Serial.ID.of.cert.to.revoke", "ID de s\u00e9rie do certificado a ser revogado" }, { "keytool.error.", "erro de keytool: " }, { "Illegal.option.", "Op\u00e7\u00e3o inv\u00e1lida:  " }, { "Illegal.value.", "Valor inv\u00e1lido: " }, { "Unknown.password.type.", "Tipo de senha desconhecido: " }, { "Cannot.find.environment.variable.", "N\u00e3o \u00e9 poss\u00edvel localizar a vari\u00e1vel do ambiente: " }, { "Cannot.find.file.", "N\u00e3o \u00e9 poss\u00edvel localizar o arquivo: " }, { "Command.option.flag.needs.an.argument.", "A op\u00e7\u00e3o de comando {0} precisa de um argumento." }, { "Warning.Different.store.and.key.passwords.not.supported.for.PKCS12.KeyStores.Ignoring.user.specified.command.value.", "Advert\u00eancia: Senhas de chave e de armazenamento diferentes n\u00e3o suportadas para KeyStores PKCS12. Ignorando valor {0} especificado pelo usu\u00e1rio." }, { ".keystore.must.be.NONE.if.storetype.is.{0}", "-keystore deve ser NONE se -storetype for {0}" }, { "Too.many.retries.program.terminated", "Excesso de tentativas de repeti\u00e7\u00e3o; programa finalizado" }, { ".storepasswd.and.keypasswd.commands.not.supported.if.storetype.is.{0}", "comandos -storepasswd e -keypasswd n\u00e3o suportados se -storetype for {0}" }, { ".keypasswd.commands.not.supported.if.storetype.is.PKCS12", "comandos -keypasswd n\u00e3o suportados se -storetype for PKCS12" }, { ".keypass.and.new.can.not.be.specified.if.storetype.is.{0}", "-keypass e -new n\u00e3o podem ser especificados se -storetype for {0}" }, { "if.protected.is.specified.then.storepass.keypass.and.new.must.not.be.specified", "se -protected for especificado, ent\u00e3o -storepass, -keypass e -new n\u00e3o dever\u00e3o ser especificados" }, { "if.srcprotected.is.specified.then.srcstorepass.and.srckeypass.must.not.be.specified", "se -srcprotected for especificado, ent\u00e3o -srcstorepass e -srckeypass n\u00e3o dever\u00e3o ser especificados" }, { "if.keystore.is.not.password.protected.then.storepass.keypass.and.new.must.not.be.specified", "se a \u00e1rea de armazenamento de chaves n\u00e3o estiver protegida por senha, ent\u00e3o -storepass, -keypass e -new n\u00e3o dever\u00e3o ser especificados" }, { "if.source.keystore.is.not.password.protected.then.srcstorepass.and.srckeypass.must.not.be.specified", "se a \u00e1rea de armazenamento de chaves de origem n\u00e3o estiver protegida por senha, ent\u00e3o -srcstorepass e -srckeypass n\u00e3o dever\u00e3o ser especificados" }, { "Illegal.startdate.value", "valor da data inicial inv\u00e1lido" }, { "Validity.must.be.greater.than.zero", "A validade deve ser maior do que zero" }, { "provName.not.a.provider", "{0} n\u00e3o \u00e9 um fornecedor" }, { "Usage.error.no.command.provided", "Erro de uso: nenhum comando fornecido" }, { "Source.keystore.file.exists.but.is.empty.", "O arquivo da \u00e1rea de armazenamento de chaves de origem existe, mas est\u00e1 vazio: " }, { "Please.specify.srckeystore", "Especifique -srckeystore" }, { "Must.not.specify.both.v.and.rfc.with.list.command", "N\u00e3o devem ser especificados -v e -rfc com o comando 'list'" }, { "Key.password.must.be.at.least.6.characters", "A senha da chave deve ter, no m\u00ednimo, 6 caracteres" }, { "New.password.must.be.at.least.6.characters", "A nova senha deve ter, no m\u00ednimo, 6 caracteres" }, { "Keystore.file.exists.but.is.empty.", "O arquivo da \u00e1rea de armazenamento de chaves existe, mas est\u00e1 vazio: " }, { "Keystore.file.does.not.exist.", "O arquivo da \u00e1rea de armazenamento de chaves n\u00e3o existe. " }, { "Must.specify.destination.alias", "Deve ser especificado um alias de destino" }, { "Must.specify.alias", "Deve ser especificado um alias" }, { "Keystore.password.must.be.at.least.6.characters", "A senha da \u00e1rea de armazenamento de chaves deve ter, no m\u00ednimo, 6 caracteres" }, { "Enter.the.password.to.be.stored.", "Digite a senha a ser armazenada:  " }, { "Enter.keystore.password.", "Informe a senha da \u00e1rea de armazenamento de chaves:  " }, { "Enter.source.keystore.password.", "Informe a senha da \u00e1rea de armazenamento de chaves de origem:  " }, { "Enter.destination.keystore.password.", "Informe a senha da \u00e1rea de armazenamento de chaves de destino:  " }, { "Keystore.password.is.too.short.must.be.at.least.6.characters", "A senha da \u00e1rea de armazenamento de chaves \u00e9 muito curta - ela deve ter, no m\u00ednimo, 6 caracteres" }, { "Unknown.Entry.Type", "Tipo de Entrada Desconhecido" }, { "Too.many.failures.Alias.not.changed", "Excesso de falhas. Alias n\u00e3o alterado" }, { "Entry.for.alias.alias.successfully.imported.", "Entrada do alias {0} importada com \u00eaxito." }, { "Entry.for.alias.alias.not.imported.", "Entrada do alias {0} n\u00e3o importada." }, { "Problem.importing.entry.for.alias.alias.exception.Entry.for.alias.alias.not.imported.", "Problema ao importar a entrada do alias {0}: {1}.\nEntrada do alias {0} n\u00e3o importada." }, { "Import.command.completed.ok.entries.successfully.imported.fail.entries.failed.or.cancelled", "Comando de importa\u00e7\u00e3o conclu\u00eddo:  {0} entradas importadas com \u00eaxito, {1} entradas falharam ou foram canceladas" }, { "Warning.Overwriting.existing.alias.alias.in.destination.keystore", "Advert\u00eancia: Substitui\u00e7\u00e3o do alias {0} existente na \u00e1rea de armazenamento de chaves de destino" }, { "Existing.entry.alias.alias.exists.overwrite.no.", "Entrada j\u00e1 existente no alias {0}, substituir? [n\u00e3o]:  " }, { "Too.many.failures.try.later", "Excesso de falhas - tente mais tarde" }, { "Certification.request.stored.in.file.filename.", "Solicita\u00e7\u00e3o de certificado armazenada no arquivo <{0}>" }, { "Submit.this.to.your.CA", "Submeter \u00e0 CA" }, { "if.alias.not.specified.destalias.and.srckeypass.must.not.be.specified", "se o alias n\u00e3o estiver especificado, destalias e srckeypass n\u00e3o dever\u00e3o ser especificados" }, { "The.destination.pkcs12.keystore.has.different.storepass.and.keypass.Please.retry.with.destkeypass.specified.", "O armazenamento de chaves pkcs12 de destino tem storepass e keypass diferentes. Tente novamente especificando -destkeypass." }, { "Certificate.stored.in.file.filename.", "Certificado armazenado no arquivo <{0}>" }, { "Certificate.reply.was.installed.in.keystore", "A resposta do certificado foi instalada na \u00e1rea de armazenamento de chaves" }, { "Certificate.reply.was.not.installed.in.keystore", "A resposta do certificado n\u00e3o foi instalada na \u00e1rea de armazenamento de chaves" }, { "Certificate.was.added.to.keystore", "O certificado foi adicionado \u00e0 \u00e1rea de armazenamento de chaves" }, { "Certificate.was.not.added.to.keystore", "O certificado n\u00e3o foi adicionado \u00e0 \u00e1rea de armazenamento de chaves" }, { ".Storing.ksfname.", "[Armazenando {0}]" }, { "alias.has.no.public.key.certificate.", "{0} n\u00e3o tem chave p\u00fablica (certificado)" }, { "Cannot.derive.signature.algorithm", "N\u00e3o \u00e9 poss\u00edvel obter um algoritmo de assinatura" }, { "Alias.alias.does.not.exist", "O alias <{0}> n\u00e3o existe" }, { "Alias.alias.has.no.certificate", "O alias <{0}> n\u00e3o tem certificado" }, { "Key.pair.not.generated.alias.alias.already.exists", "Par de chaves n\u00e3o gerado; o alias <{0}> j\u00e1 existe" }, { "Generating.keysize.bit.keyAlgName.key.pair.and.self.signed.certificate.sigAlgName.with.a.validity.of.validality.days.for", "Gerando o par de chaves {1} de {0} bit e o certificado autoassinado ({2}) com uma validade de {3} dias\n\tpara: {4}" }, { "Enter.key.password.for.alias.", "Informar a senha da chave de <{0}>" }, { ".RETURN.if.same.as.keystore.password.", "\t(RETURN se for igual \u00e0 senha da \u00e1rea do armazenamento de chaves):  " }, { "Key.password.is.too.short.must.be.at.least.6.characters", "A senha da chave \u00e9 muito curta - deve ter, no m\u00ednimo, 6 caracteres" }, { "Too.many.failures.key.not.added.to.keystore", "Excesso de falhas - chave n\u00e3o adicionada a \u00e1rea de armazenamento de chaves" }, { "Destination.alias.dest.already.exists", "O alias de destino <{0}> j\u00e1 existe" }, { "Password.is.too.short.must.be.at.least.6.characters", "A senha \u00e9 muito curta - deve ter, no m\u00ednimo, 6 caracteres" }, { "Too.many.failures.Key.entry.not.cloned", "Excesso de falhas. Entrada da chave n\u00e3o clonada" }, { "key.password.for.alias.", "senha da chave de <{0}>" }, { "Keystore.entry.for.id.getName.already.exists", "A entrada da \u00e1rea do armazenamento de chaves de <{0}> j\u00e1 existe" }, { "Creating.keystore.entry.for.id.getName.", "Criando entrada da \u00e1rea do armazenamento de chaves para <{0}> ..." }, { "No.entries.from.identity.database.added", "Nenhuma entrada adicionada do banco de dados de identidades" }, { "Alias.name.alias", "Nome do alias: {0}" }, { "Creation.date.keyStore.getCreationDate.alias.", "Data de cria\u00e7\u00e3o: {0,date}" }, { "alias.keyStore.getCreationDate.alias.", "{0}, {1,date}, " }, { "alias.", "{0}, " }, { "Entry.type.type.", "Tipo de entrada: {0}" }, { "Certificate.chain.length.", "Comprimento da cadeia de certificados: " }, { "Certificate.i.1.", "Certificado[{0,number,integer}]:" }, { "Certificate.fingerprint.SHA1.", "Fingerprint (SHA1) do certificado: " }, { "Keystore.type.", "Tipo de \u00e1rea de armazenamento de chaves: " }, { "Keystore.provider.", "Fornecedor da \u00e1rea de armazenamento de chaves: " }, { "Your.keystore.contains.keyStore.size.entry", "Sua \u00e1rea de armazenamento de chaves cont\u00e9m {0,number,integer} entrada" }, { "Your.keystore.contains.keyStore.size.entries", "Sua \u00e1rea de armazenamento de chaves cont\u00e9m {0,number,integer} entradas" }, { "Failed.to.parse.input", "Falha durante o parsing da entrada" }, { "Empty.input", "Entrada vazia" }, { "Not.X.509.certificate", "N\u00e3o \u00e9 um certificado X.509" }, { "alias.has.no.public.key", "{0} n\u00e3o tem chave p\u00fablica" }, { "alias.has.no.X.509.certificate", "{0} n\u00e3o tem certificado X.509" }, { "New.certificate.self.signed.", "Novo certificado (autoassinado):" }, { "Reply.has.no.certificates", "A resposta n\u00e3o tem certificado" }, { "Certificate.not.imported.alias.alias.already.exists", "Certificado n\u00e3o importado, o alias <{0}> j\u00e1 existe" }, { "Input.not.an.X.509.certificate", "A entrada n\u00e3o \u00e9 um certificado X.509" }, { "Certificate.already.exists.in.keystore.under.alias.trustalias.", "O certificado j\u00e1 existe no armazenamento de chaves no alias <{0}>" }, { "Do.you.still.want.to.add.it.no.", "Ainda deseja adicion\u00e1-lo? [n\u00e3o]:  " }, { "Certificate.already.exists.in.system.wide.CA.keystore.under.alias.trustalias.", "O certificado j\u00e1 existe na \u00e1rea de armazenamento de chaves da CA em todo o sistema no alias <{0}>" }, { "Do.you.still.want.to.add.it.to.your.own.keystore.no.", "Ainda deseja adicion\u00e1-lo \u00e0 sua \u00e1rea de armazenamento de chaves? [n\u00e3o]:  " }, { "Trust.this.certificate.no.", "Confiar neste certificado? [n\u00e3o]:  " }, { "YES", "SIM" }, { "New.prompt.", "Nova {0}: " }, { "Passwords.must.differ", "As senhas devem ser diferentes" }, { "Re.enter.new.prompt.", "Informe novamente a nova {0}: " }, { "Re.enter.password.", "Redigite a senha: " }, { "Re.enter.new.password.", "Informe novamente a nova senha: " }, { "They.don.t.match.Try.again", "Elas n\u00e3o correspondem. Tente novamente" }, { "Enter.prompt.alias.name.", "Informe o nome do alias {0}:  " }, { "Enter.new.alias.name.RETURN.to.cancel.import.for.this.entry.", "Informe o novo nome do alias\t(RETURN para cancelar a importa\u00e7\u00e3o desta entrada):  " }, { "Enter.alias.name.", "Informe o nome do alias:  " }, { ".RETURN.if.same.as.for.otherAlias.", "\t(RETURN se for igual ao de <{0}>)" }, { "What.is.your.first.and.last.name.", "Qual \u00e9 o seu nome e o seu sobrenome?" }, { "What.is.the.name.of.your.organizational.unit.", "Qual \u00e9 o nome da sua unidade organizacional?" }, { "What.is.the.name.of.your.organization.", "Qual \u00e9 o nome da sua empresa?" }, { "What.is.the.name.of.your.City.or.Locality.", "Qual \u00e9 o nome da sua Cidade ou Localidade?" }, { "What.is.the.name.of.your.State.or.Province.", "Qual \u00e9 o nome do seu Estado ou Munic\u00edpio?" }, { "What.is.the.two.letter.country.code.for.this.unit.", "Quais s\u00e3o as duas letras do c\u00f3digo do pa\u00eds desta unidade?" }, { "Is.name.correct.", "{0} Est\u00e1 correto?" }, { "no", "n\u00e3o" }, { "yes", "sim" }, { "y", "s" }, { ".defaultValue.", "  [{0}]:  " }, { "Alias.alias.has.no.key", "O alias <{0}> n\u00e3o tem chave" }, { "Alias.alias.references.an.entry.type.that.is.not.a.private.key.entry.The.keyclone.command.only.supports.cloning.of.private.key", "O alias <{0}> faz refer\u00eancia a um tipo de entrada que n\u00e3o \u00e9 uma entrada de chave privada. O comando -keyclone oferece suporte somente \u00e0 clonagem de entradas de chave privada" }, { ".WARNING.WARNING.WARNING.", "*****************  WARNING WARNING WARNING  *****************" }, { "Signer.d.", "Signat\u00e1rio #%d:" }, { "Timestamp.", "Timestamp:" }, { "Signature.", "Assinatura:" }, { "CRLs.", "CRLs:" }, { "Certificate.owner.", "Propriet\u00e1rio do certificado: " }, { "Not.a.signed.jar.file", "N\u00e3o \u00e9 um arquivo jar assinado" }, { "No.certificate.from.the.SSL.server", "N\u00e3o \u00e9 um certificado do servidor SSL" }, { ".The.integrity.of.the.information.stored.in.your.keystore.", "* A integridade das informa\u00e7\u00f5es armazenadas na sua \u00e1rea de armazenamento de chaves  *\n* N\u00c3O foi verificada!  Para que seja poss\u00edvel verificar sua integridade, *\n* voc\u00ea deve fornecer a senha da \u00e1rea de armazenamento de chaves.                  *" }, { ".The.integrity.of.the.information.stored.in.the.srckeystore.", "* A integridade das informa\u00e7\u00f5es armazenadas no srckeystore  *\n* N\u00c3O foi verificada!  Para que seja poss\u00edvel verificar sua integridade, *\n* voc\u00ea deve fornecer a senha do srckeystore.                  *" }, { "Certificate.reply.does.not.contain.public.key.for.alias.", "A resposta do certificado n\u00e3o cont\u00e9m a chave p\u00fablica de <{0}>" }, { "Incomplete.certificate.chain.in.reply", "Cadeia de certificados incompleta na resposta" }, { "Certificate.chain.in.reply.does.not.verify.", "A cadeia de certificados da resposta n\u00e3o verifica: " }, { "Top.level.certificate.in.reply.", "Certificado de n\u00edvel superior na resposta:\n" }, { ".is.not.trusted.", "... n\u00e3o \u00e9 confi\u00e1vel. " }, { "Install.reply.anyway.no.", "Instalar resposta assim mesmo? [n\u00e3o]:  " }, { "NO", "N\u00c3O" }, { "Public.keys.in.reply.and.keystore.don.t.match", "As chaves p\u00fablicas da resposta e da \u00e1rea de armazenamento de chaves n\u00e3o correspondem" }, { "Certificate.reply.and.certificate.in.keystore.are.identical", "O certificado da resposta e o certificado da \u00e1rea de armazenamento de chaves s\u00e3o id\u00eanticos" }, { "Failed.to.establish.chain.from.reply", "Falha ao estabelecer a cadeia a partir da resposta" }, { "n", "n" }, { "Wrong.answer.try.again", "Resposta errada; tente novamente" }, { "Secret.key.not.generated.alias.alias.already.exists", "Chave secreta n\u00e3o gerada; o alias <{0}> j\u00e1 existe" }, { "Please.provide.keysize.for.secret.key.generation", "Forne\u00e7a o -keysize para a gera\u00e7\u00e3o da chave secreta" }, { "warning.not.verified.make.sure.keystore.is.correct", "ADVERT\u00caNCIA: n\u00e3o verificado. Certifique-se que -keystore esteja correto." }, { "Extensions.", "Extens\u00f5es: " }, { ".Empty.value.", "(Valor vazio)" }, { "Extension.Request.", "Solicita\u00e7\u00e3o de Extens\u00e3o:" }, { "Unknown.keyUsage.type.", "Tipo de keyUsage desconhecido: " }, { "Unknown.extendedkeyUsage.type.", "Tipo de extendedkeyUsage desconhecido: " }, { "Unknown.AccessDescription.type.", "Tipo de AccessDescription desconhecido: " }, { "Unrecognized.GeneralName.type.", "Tipo de GeneralName n\u00e3o reconhecido: " }, { "This.extension.cannot.be.marked.as.critical.", "Esta extens\u00e3o n\u00e3o pode ser marcada como cr\u00edtica. " }, { "Odd.number.of.hex.digits.found.", "Encontrado n\u00famero \u00edmpar de seis d\u00edgitos: " }, { "Unknown.extension.type.", "Tipo de extens\u00e3o desconhecido: " }, { "command.{0}.is.ambiguous.", "o comando {0} \u00e9 amb\u00edguo:" }, { "the.certificate.request", "A solicita\u00e7\u00e3o do certificado" }, { "the.issuer", "O emissor" }, { "the.generated.certificate", "O certificado gerado" }, { "the.generated.crl", "A CRL gerada" }, { "the.generated.certificate.request", "A solicita\u00e7\u00e3o do certificado gerada" }, { "the.certificate", "O certificado" }, { "the.crl", "A CRL" }, { "the.tsa.certificate", "O certificado TSA" }, { "the.input", "A entrada" }, { "reply", "Resposta" }, { "one.in.many", "%1$s #%2$d de %3$d" }, { "alias.in.cacerts", "Emissor <%s> no cacerts" }, { "alias.in.keystore", "Emissor <%s>" }, { "with.weak", "%s (fraca)" }, { "key.bit", "Chave %2$s de %1$d bits" }, { "key.bit.weak", "Chave %2$s de %1$d bits (fraca)" }, { ".PATTERN.printX509Cert.with.weak", "Propriet\u00e1rio: {0}\nEmissor: {1}\nN\u00famero de s\u00e9rie: {2}\nV\u00e1lido de {3} at\u00e9 {4}\nFingerprints do certificado:\n\t MD5:  {5}\n\t SHA1: {6}\n\t SHA256: {7}\nNome do algoritmo de assinatura: {8}\nAlgoritmo de Chave P\u00fablica do Assunto: {9}\nVers\u00e3o: {10}" }, { "PKCS.10.with.weak", "Solicita\u00e7\u00e3o do Certificado PKCS #10 (Vers\u00e3o 1.0)\nAssunto: %1$s\nFormato: %2$s\nChave P\u00fablica: %3$s\nAlgoritmo de assinatura: %4$s\n" }, { "verified.by.s.in.s.weak", "Verificado por %1$s em %2$s com um %3$s" }, { "whose.sigalg.risk", "%1$s usa o algoritmo de assinatura %2$s que \u00e9 considerado um risco \u00e0 seguran\u00e7a." }, { "whose.key.risk", "%1$s usa um %2$s que \u00e9 considerado um risco \u00e0 seguran\u00e7a." }, { "jks.storetype.warning", "O armazenamento de chaves %1$s usa um formato propriet\u00e1rio. \u00c9 recomendada a migra\u00e7\u00e3o para PKCS12, que \u00e9 um formato de padr\u00e3o industrial que usa \"keytool -importkeystore -srckeystore %2$s -destkeystore %2$s -deststoretype pkcs12\"." }, { "migrate.keystore.warning", "\"%1$s\" foi migrado para %4$s. O backup do armazenamento de chaves %2$s \u00e9 feito como \"%3$s\"." }, { "backup.keystore.warning", "O backup do armazenamento de chaves original \"%1$s\" \u00e9 feito como \"%3$s\"..." }, { "importing.keystore.status", "Importando armazenamento de chaves %1$s to %2$s..." } };
    }
}
