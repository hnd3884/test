package org.apache.tomcat.dbcp.dbcp2;

import java.util.Objects;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Connection;
import java.util.Arrays;

public class PStmtKey
{
    private final String sql;
    private final Integer resultSetType;
    private final Integer resultSetConcurrency;
    private final Integer resultSetHoldability;
    private final String catalog;
    private final String schema;
    private final Integer autoGeneratedKeys;
    private final int[] columnIndexes;
    private final String[] columnNames;
    private final PoolingConnection.StatementType statementType;
    private transient StatementBuilder builder;
    
    @Deprecated
    public PStmtKey(final String sql) {
        this(sql, null, PoolingConnection.StatementType.PREPARED_STATEMENT);
    }
    
    @Deprecated
    public PStmtKey(final String sql, final int resultSetType, final int resultSetConcurrency) {
        this(sql, null, resultSetType, resultSetConcurrency, PoolingConnection.StatementType.PREPARED_STATEMENT);
    }
    
    @Deprecated
    public PStmtKey(final String sql, final String catalog) {
        this(sql, catalog, PoolingConnection.StatementType.PREPARED_STATEMENT);
    }
    
    @Deprecated
    public PStmtKey(final String sql, final String catalog, final int autoGeneratedKeys) {
        this(sql, catalog, PoolingConnection.StatementType.PREPARED_STATEMENT, autoGeneratedKeys);
    }
    
    @Deprecated
    public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency) {
        this(sql, catalog, resultSetType, resultSetConcurrency, PoolingConnection.StatementType.PREPARED_STATEMENT);
    }
    
    @Deprecated
    public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) {
        this(sql, catalog, resultSetType, resultSetConcurrency, resultSetHoldability, PoolingConnection.StatementType.PREPARED_STATEMENT);
    }
    
    @Deprecated
    public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability, final PoolingConnection.StatementType statementType) {
        this.sql = sql;
        this.catalog = catalog;
        this.schema = null;
        this.resultSetType = resultSetType;
        this.resultSetConcurrency = resultSetConcurrency;
        this.resultSetHoldability = resultSetHoldability;
        this.statementType = statementType;
        this.autoGeneratedKeys = null;
        this.columnIndexes = null;
        this.columnNames = null;
        if (statementType == PoolingConnection.StatementType.PREPARED_STATEMENT) {
            this.builder = new PreparedStatementWithResultSetHoldability();
        }
        else if (statementType == PoolingConnection.StatementType.CALLABLE_STATEMENT) {
            this.builder = new PreparedCallWithResultSetHoldability();
        }
    }
    
    @Deprecated
    public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency, final PoolingConnection.StatementType statementType) {
        this.sql = sql;
        this.catalog = catalog;
        this.schema = null;
        this.resultSetType = resultSetType;
        this.resultSetConcurrency = resultSetConcurrency;
        this.resultSetHoldability = null;
        this.statementType = statementType;
        this.autoGeneratedKeys = null;
        this.columnIndexes = null;
        this.columnNames = null;
        if (statementType == PoolingConnection.StatementType.PREPARED_STATEMENT) {
            this.builder = new PreparedStatementWithResultSetConcurrency();
        }
        else if (statementType == PoolingConnection.StatementType.CALLABLE_STATEMENT) {
            this.builder = new PreparedCallWithResultSetConcurrency();
        }
    }
    
    @Deprecated
    public PStmtKey(final String sql, final String catalog, final int[] columnIndexes) {
        this.sql = sql;
        this.catalog = catalog;
        this.schema = null;
        this.statementType = PoolingConnection.StatementType.PREPARED_STATEMENT;
        this.autoGeneratedKeys = null;
        this.columnIndexes = (int[])((columnIndexes == null) ? null : Arrays.copyOf(columnIndexes, columnIndexes.length));
        this.columnNames = null;
        this.resultSetType = null;
        this.resultSetConcurrency = null;
        this.resultSetHoldability = null;
        this.builder = new PreparedStatementWithColumnIndexes();
    }
    
    @Deprecated
    public PStmtKey(final String sql, final String catalog, final PoolingConnection.StatementType statementType) {
        this.sql = sql;
        this.catalog = catalog;
        this.schema = null;
        this.statementType = statementType;
        this.autoGeneratedKeys = null;
        this.columnIndexes = null;
        this.columnNames = null;
        this.resultSetType = null;
        this.resultSetConcurrency = null;
        this.resultSetHoldability = null;
        if (statementType == PoolingConnection.StatementType.PREPARED_STATEMENT) {
            this.builder = new PreparedStatementSQL();
        }
        else if (statementType == PoolingConnection.StatementType.CALLABLE_STATEMENT) {
            this.builder = new PreparedCallSQL();
        }
    }
    
    @Deprecated
    public PStmtKey(final String sql, final String catalog, final PoolingConnection.StatementType statementType, final Integer autoGeneratedKeys) {
        this.sql = sql;
        this.catalog = catalog;
        this.schema = null;
        this.statementType = statementType;
        this.autoGeneratedKeys = autoGeneratedKeys;
        this.columnIndexes = null;
        this.columnNames = null;
        this.resultSetType = null;
        this.resultSetConcurrency = null;
        this.resultSetHoldability = null;
        if (statementType == PoolingConnection.StatementType.PREPARED_STATEMENT) {
            this.builder = new PreparedStatementWithAutoGeneratedKeys();
        }
        else if (statementType == PoolingConnection.StatementType.CALLABLE_STATEMENT) {
            this.builder = new PreparedCallSQL();
        }
    }
    
    public PStmtKey(final String sql, final String catalog, final String schema) {
        this(sql, catalog, schema, PoolingConnection.StatementType.PREPARED_STATEMENT);
    }
    
    public PStmtKey(final String sql, final String catalog, final String schema, final int autoGeneratedKeys) {
        this(sql, catalog, schema, PoolingConnection.StatementType.PREPARED_STATEMENT, autoGeneratedKeys);
    }
    
    public PStmtKey(final String sql, final String catalog, final String schema, final int resultSetType, final int resultSetConcurrency) {
        this(sql, catalog, schema, resultSetType, resultSetConcurrency, PoolingConnection.StatementType.PREPARED_STATEMENT);
    }
    
    public PStmtKey(final String sql, final String catalog, final String schema, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) {
        this(sql, catalog, schema, resultSetType, resultSetConcurrency, resultSetHoldability, PoolingConnection.StatementType.PREPARED_STATEMENT);
    }
    
    public PStmtKey(final String sql, final String catalog, final String schema, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability, final PoolingConnection.StatementType statementType) {
        this.sql = sql;
        this.catalog = catalog;
        this.schema = schema;
        this.resultSetType = resultSetType;
        this.resultSetConcurrency = resultSetConcurrency;
        this.resultSetHoldability = resultSetHoldability;
        this.statementType = statementType;
        this.autoGeneratedKeys = null;
        this.columnIndexes = null;
        this.columnNames = null;
        if (statementType == PoolingConnection.StatementType.PREPARED_STATEMENT) {
            this.builder = new PreparedStatementWithResultSetHoldability();
        }
        else if (statementType == PoolingConnection.StatementType.CALLABLE_STATEMENT) {
            this.builder = new PreparedCallWithResultSetHoldability();
        }
    }
    
    public PStmtKey(final String sql, final String catalog, final String schema, final int resultSetType, final int resultSetConcurrency, final PoolingConnection.StatementType statementType) {
        this.sql = sql;
        this.catalog = catalog;
        this.schema = schema;
        this.resultSetType = resultSetType;
        this.resultSetConcurrency = resultSetConcurrency;
        this.resultSetHoldability = null;
        this.statementType = statementType;
        this.autoGeneratedKeys = null;
        this.columnIndexes = null;
        this.columnNames = null;
        if (statementType == PoolingConnection.StatementType.PREPARED_STATEMENT) {
            this.builder = new PreparedStatementWithResultSetConcurrency();
        }
        else if (statementType == PoolingConnection.StatementType.CALLABLE_STATEMENT) {
            this.builder = new PreparedCallWithResultSetConcurrency();
        }
    }
    
    public PStmtKey(final String sql, final String catalog, final String schema, final int[] columnIndexes) {
        this.sql = sql;
        this.catalog = catalog;
        this.schema = schema;
        this.statementType = PoolingConnection.StatementType.PREPARED_STATEMENT;
        this.autoGeneratedKeys = null;
        this.columnIndexes = (int[])((columnIndexes == null) ? null : Arrays.copyOf(columnIndexes, columnIndexes.length));
        this.columnNames = null;
        this.resultSetType = null;
        this.resultSetConcurrency = null;
        this.resultSetHoldability = null;
        this.builder = new PreparedStatementWithColumnIndexes();
    }
    
    public PStmtKey(final String sql, final String catalog, final String schema, final PoolingConnection.StatementType statementType) {
        this.sql = sql;
        this.catalog = catalog;
        this.schema = schema;
        this.statementType = statementType;
        this.autoGeneratedKeys = null;
        this.columnIndexes = null;
        this.columnNames = null;
        this.resultSetType = null;
        this.resultSetConcurrency = null;
        this.resultSetHoldability = null;
        if (statementType == PoolingConnection.StatementType.PREPARED_STATEMENT) {
            this.builder = new PreparedStatementSQL();
        }
        else if (statementType == PoolingConnection.StatementType.CALLABLE_STATEMENT) {
            this.builder = new PreparedCallSQL();
        }
    }
    
    public PStmtKey(final String sql, final String catalog, final String schema, final PoolingConnection.StatementType statementType, final Integer autoGeneratedKeys) {
        this.sql = sql;
        this.catalog = catalog;
        this.schema = schema;
        this.statementType = statementType;
        this.autoGeneratedKeys = autoGeneratedKeys;
        this.columnIndexes = null;
        this.columnNames = null;
        this.resultSetType = null;
        this.resultSetConcurrency = null;
        this.resultSetHoldability = null;
        if (statementType == PoolingConnection.StatementType.PREPARED_STATEMENT) {
            this.builder = new PreparedStatementWithAutoGeneratedKeys();
        }
        else if (statementType == PoolingConnection.StatementType.CALLABLE_STATEMENT) {
            this.builder = new PreparedCallSQL();
        }
    }
    
    public PStmtKey(final String sql, final String catalog, final String schema, final String[] columnNames) {
        this.sql = sql;
        this.catalog = catalog;
        this.schema = schema;
        this.statementType = PoolingConnection.StatementType.PREPARED_STATEMENT;
        this.autoGeneratedKeys = null;
        this.columnIndexes = null;
        this.columnNames = (String[])((columnNames == null) ? null : ((String[])Arrays.copyOf(columnNames, columnNames.length)));
        this.resultSetType = null;
        this.resultSetConcurrency = null;
        this.resultSetHoldability = null;
        this.builder = new PreparedStatementWithColumnNames();
    }
    
    @Deprecated
    public PStmtKey(final String sql, final String catalog, final String[] columnNames) {
        this.sql = sql;
        this.catalog = catalog;
        this.schema = null;
        this.statementType = PoolingConnection.StatementType.PREPARED_STATEMENT;
        this.autoGeneratedKeys = null;
        this.columnIndexes = null;
        this.columnNames = (String[])((columnNames == null) ? null : ((String[])Arrays.copyOf(columnNames, columnNames.length)));
        this.resultSetType = null;
        this.resultSetConcurrency = null;
        this.resultSetHoldability = null;
        this.builder = new PreparedStatementWithColumnNames();
    }
    
    public Statement createStatement(final Connection connection) throws SQLException {
        if (this.builder == null) {
            throw new IllegalStateException("Prepared statement key is invalid.");
        }
        return this.builder.createStatement(connection);
    }
    
    @Override
    public boolean equals(final Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (this.getClass() != obj.getClass()) {
            return false;
        }
        final PStmtKey other = (PStmtKey)obj;
        return Objects.equals(this.autoGeneratedKeys, other.autoGeneratedKeys) && Objects.equals(this.catalog, other.catalog) && Arrays.equals(this.columnIndexes, other.columnIndexes) && Arrays.equals(this.columnNames, other.columnNames) && Objects.equals(this.resultSetConcurrency, other.resultSetConcurrency) && Objects.equals(this.resultSetHoldability, other.resultSetHoldability) && Objects.equals(this.resultSetType, other.resultSetType) && Objects.equals(this.schema, other.schema) && Objects.equals(this.sql, other.sql) && this.statementType == other.statementType;
    }
    
    public Integer getAutoGeneratedKeys() {
        return this.autoGeneratedKeys;
    }
    
    public String getCatalog() {
        return this.catalog;
    }
    
    public int[] getColumnIndexes() {
        return (int[])((this.columnIndexes == null) ? null : ((int[])this.columnIndexes.clone()));
    }
    
    public String[] getColumnNames() {
        return (String[])((this.columnNames == null) ? null : ((String[])this.columnNames.clone()));
    }
    
    public Integer getResultSetConcurrency() {
        return this.resultSetConcurrency;
    }
    
    public Integer getResultSetHoldability() {
        return this.resultSetHoldability;
    }
    
    public Integer getResultSetType() {
        return this.resultSetType;
    }
    
    public String getSchema() {
        return this.schema;
    }
    
    public String getSql() {
        return this.sql;
    }
    
    public PoolingConnection.StatementType getStmtType() {
        return this.statementType;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(this.autoGeneratedKeys, this.catalog, Arrays.hashCode(this.columnIndexes), Arrays.hashCode(this.columnNames), this.resultSetConcurrency, this.resultSetHoldability, this.resultSetType, this.schema, this.sql, this.statementType);
    }
    
    @Override
    public String toString() {
        final StringBuilder buf = new StringBuilder();
        buf.append("PStmtKey: sql=");
        buf.append(this.sql);
        buf.append(", catalog=");
        buf.append(this.catalog);
        buf.append(", schema=");
        buf.append(this.schema);
        buf.append(", resultSetType=");
        buf.append(this.resultSetType);
        buf.append(", resultSetConcurrency=");
        buf.append(this.resultSetConcurrency);
        buf.append(", resultSetHoldability=");
        buf.append(this.resultSetHoldability);
        buf.append(", autoGeneratedKeys=");
        buf.append(this.autoGeneratedKeys);
        buf.append(", columnIndexes=");
        buf.append(Arrays.toString(this.columnIndexes));
        buf.append(", columnNames=");
        buf.append(Arrays.toString(this.columnNames));
        buf.append(", statementType=");
        buf.append(this.statementType);
        return buf.toString();
    }
    
    private class PreparedCallSQL implements StatementBuilder
    {
        @Override
        public Statement createStatement(final Connection connection) throws SQLException {
            return connection.prepareCall(PStmtKey.this.sql);
        }
    }
    
    private class PreparedCallWithResultSetConcurrency implements StatementBuilder
    {
        @Override
        public Statement createStatement(final Connection connection) throws SQLException {
            return connection.prepareCall(PStmtKey.this.sql, PStmtKey.this.resultSetType, PStmtKey.this.resultSetConcurrency);
        }
    }
    
    private class PreparedCallWithResultSetHoldability implements StatementBuilder
    {
        @Override
        public Statement createStatement(final Connection connection) throws SQLException {
            return connection.prepareCall(PStmtKey.this.sql, PStmtKey.this.resultSetType, PStmtKey.this.resultSetConcurrency, PStmtKey.this.resultSetHoldability);
        }
    }
    
    private class PreparedStatementSQL implements StatementBuilder
    {
        @Override
        public Statement createStatement(final Connection connection) throws SQLException {
            return connection.prepareStatement(PStmtKey.this.sql);
        }
    }
    
    private class PreparedStatementWithAutoGeneratedKeys implements StatementBuilder
    {
        @Override
        public Statement createStatement(final Connection connection) throws SQLException {
            return connection.prepareStatement(PStmtKey.this.sql, PStmtKey.this.autoGeneratedKeys);
        }
    }
    
    private class PreparedStatementWithColumnIndexes implements StatementBuilder
    {
        @Override
        public Statement createStatement(final Connection connection) throws SQLException {
            return connection.prepareStatement(PStmtKey.this.sql, PStmtKey.this.columnIndexes);
        }
    }
    
    private class PreparedStatementWithColumnNames implements StatementBuilder
    {
        @Override
        public Statement createStatement(final Connection connection) throws SQLException {
            return connection.prepareStatement(PStmtKey.this.sql, PStmtKey.this.columnNames);
        }
    }
    
    private class PreparedStatementWithResultSetConcurrency implements StatementBuilder
    {
        @Override
        public Statement createStatement(final Connection connection) throws SQLException {
            return connection.prepareStatement(PStmtKey.this.sql, PStmtKey.this.resultSetType, PStmtKey.this.resultSetConcurrency);
        }
    }
    
    private class PreparedStatementWithResultSetHoldability implements StatementBuilder
    {
        @Override
        public Statement createStatement(final Connection connection) throws SQLException {
            return connection.prepareStatement(PStmtKey.this.sql, PStmtKey.this.resultSetType, PStmtKey.this.resultSetConcurrency, PStmtKey.this.resultSetHoldability);
        }
    }
    
    private interface StatementBuilder
    {
        Statement createStatement(final Connection p0) throws SQLException;
    }
}
