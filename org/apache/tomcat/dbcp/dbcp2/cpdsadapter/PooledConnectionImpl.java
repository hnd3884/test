package org.apache.tomcat.dbcp.dbcp2.cpdsadapter;

import javax.sql.ConnectionEvent;
import org.apache.tomcat.dbcp.dbcp2.PoolableCallableStatement;
import java.sql.CallableStatement;
import org.apache.tomcat.dbcp.pool2.impl.DefaultPooledObject;
import org.apache.tomcat.dbcp.dbcp2.PoolablePreparedStatement;
import java.sql.PreparedStatement;
import org.apache.tomcat.dbcp.dbcp2.Jdbc41Bridge;
import org.apache.tomcat.dbcp.pool2.DestroyMode;
import org.apache.tomcat.dbcp.dbcp2.PoolingConnection;
import java.sql.SQLException;
import org.apache.tomcat.dbcp.pool2.PooledObject;
import java.util.Collections;
import java.util.ArrayList;
import org.apache.tomcat.dbcp.pool2.KeyedObjectPool;
import javax.sql.StatementEventListener;
import javax.sql.ConnectionEventListener;
import java.util.List;
import org.apache.tomcat.dbcp.dbcp2.DelegatingConnection;
import java.sql.Connection;
import org.apache.tomcat.dbcp.dbcp2.DelegatingPreparedStatement;
import org.apache.tomcat.dbcp.dbcp2.PStmtKey;
import org.apache.tomcat.dbcp.pool2.KeyedPooledObjectFactory;
import javax.sql.PooledConnection;

class PooledConnectionImpl implements PooledConnection, KeyedPooledObjectFactory<PStmtKey, DelegatingPreparedStatement>
{
    private static final String CLOSED = "Attempted to use PooledConnection after closed() was called.";
    private Connection connection;
    private final DelegatingConnection<?> delegatingConnection;
    private Connection logicalConnection;
    private final List<ConnectionEventListener> eventListeners;
    private final List<StatementEventListener> statementEventListeners;
    private boolean closed;
    private KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> pStmtPool;
    private boolean accessToUnderlyingConnectionAllowed;
    
    PooledConnectionImpl(final Connection connection) {
        this.statementEventListeners = Collections.synchronizedList(new ArrayList<StatementEventListener>());
        this.connection = connection;
        if (connection instanceof DelegatingConnection) {
            this.delegatingConnection = (DelegatingConnection)connection;
        }
        else {
            this.delegatingConnection = new DelegatingConnection<Object>(connection);
        }
        this.eventListeners = Collections.synchronizedList(new ArrayList<ConnectionEventListener>());
        this.closed = false;
    }
    
    @Override
    public void activateObject(final PStmtKey key, final PooledObject<DelegatingPreparedStatement> pooledObject) throws Exception {
        pooledObject.getObject().activate();
    }
    
    @Override
    public void addConnectionEventListener(final ConnectionEventListener listener) {
        if (!this.eventListeners.contains(listener)) {
            this.eventListeners.add(listener);
        }
    }
    
    @Override
    public void addStatementEventListener(final StatementEventListener listener) {
        if (!this.statementEventListeners.contains(listener)) {
            this.statementEventListeners.add(listener);
        }
    }
    
    private void assertOpen() throws SQLException {
        if (this.closed) {
            throw new SQLException("Attempted to use PooledConnection after closed() was called.");
        }
    }
    
    @Override
    public void close() throws SQLException {
        this.assertOpen();
        this.closed = true;
        try {
            if (this.pStmtPool != null) {
                try {
                    this.pStmtPool.close();
                }
                finally {
                    this.pStmtPool = null;
                }
            }
        }
        catch (final RuntimeException e) {
            throw e;
        }
        catch (final Exception e2) {
            throw new SQLException("Cannot close connection (return to pool failed)", e2);
        }
        finally {
            try {
                this.connection.close();
            }
            finally {
                this.connection = null;
            }
        }
    }
    
    protected PStmtKey createKey(final String sql) {
        return new PStmtKey(this.normalizeSQL(sql), this.getCatalogOrNull(), this.getSchemaOrNull());
    }
    
    protected PStmtKey createKey(final String sql, final int autoGeneratedKeys) {
        return new PStmtKey(this.normalizeSQL(sql), this.getCatalogOrNull(), this.getSchemaOrNull(), autoGeneratedKeys);
    }
    
    protected PStmtKey createKey(final String sql, final int[] columnIndexes) {
        return new PStmtKey(this.normalizeSQL(sql), this.getCatalogOrNull(), this.getSchemaOrNull(), columnIndexes);
    }
    
    protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency) {
        return new PStmtKey(this.normalizeSQL(sql), this.getCatalogOrNull(), this.getSchemaOrNull(), resultSetType, resultSetConcurrency);
    }
    
    protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) {
        return new PStmtKey(this.normalizeSQL(sql), this.getCatalogOrNull(), this.getSchemaOrNull(), resultSetType, resultSetConcurrency, resultSetHoldability);
    }
    
    protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability, final PoolingConnection.StatementType statementType) {
        return new PStmtKey(this.normalizeSQL(sql), this.getCatalogOrNull(), this.getSchemaOrNull(), resultSetType, resultSetConcurrency, resultSetHoldability, statementType);
    }
    
    protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency, final PoolingConnection.StatementType statementType) {
        return new PStmtKey(this.normalizeSQL(sql), this.getCatalogOrNull(), this.getSchemaOrNull(), resultSetType, resultSetConcurrency, statementType);
    }
    
    protected PStmtKey createKey(final String sql, final PoolingConnection.StatementType statementType) {
        return new PStmtKey(this.normalizeSQL(sql), this.getCatalogOrNull(), this.getSchemaOrNull(), statementType);
    }
    
    protected PStmtKey createKey(final String sql, final String[] columnNames) {
        return new PStmtKey(this.normalizeSQL(sql), this.getCatalogOrNull(), this.getSchemaOrNull(), columnNames);
    }
    
    @Override
    public void destroyObject(final PStmtKey key, final PooledObject<DelegatingPreparedStatement> pooledObject) throws Exception {
        pooledObject.getObject().getInnermostDelegate().close();
    }
    
    @Override
    public void destroyObject(final PStmtKey key, final PooledObject<DelegatingPreparedStatement> p, final DestroyMode mode) throws Exception {
        this.destroyObject(key, p);
    }
    
    @Override
    protected void finalize() throws Throwable {
        try {
            this.connection.close();
        }
        catch (final Exception ex) {}
        if (this.logicalConnection != null && !this.logicalConnection.isClosed()) {
            throw new SQLException("PooledConnection was gc'ed, without its last Connection being closed.");
        }
    }
    
    private String getCatalogOrNull() {
        try {
            return (this.connection == null) ? null : this.connection.getCatalog();
        }
        catch (final SQLException e) {
            return null;
        }
    }
    
    private String getSchemaOrNull() {
        try {
            return (this.connection == null) ? null : Jdbc41Bridge.getSchema(this.connection);
        }
        catch (final SQLException e) {
            return null;
        }
    }
    
    @Override
    public Connection getConnection() throws SQLException {
        this.assertOpen();
        if (this.logicalConnection != null && !this.logicalConnection.isClosed()) {
            throw new SQLException("PooledConnection was reused, without its previous Connection being closed.");
        }
        return this.logicalConnection = new ConnectionImpl(this, this.connection, this.isAccessToUnderlyingConnectionAllowed());
    }
    
    public synchronized boolean isAccessToUnderlyingConnectionAllowed() {
        return this.accessToUnderlyingConnectionAllowed;
    }
    
    @Override
    public PooledObject<DelegatingPreparedStatement> makeObject(final PStmtKey key) throws Exception {
        if (null == key) {
            throw new IllegalArgumentException("Prepared statement key is null or invalid.");
        }
        if (key.getStmtType() == PoolingConnection.StatementType.PREPARED_STATEMENT) {
            final PreparedStatement statement = (PreparedStatement)key.createStatement(this.connection);
            final PoolablePreparedStatement pps = new PoolablePreparedStatement(statement, (K)key, (KeyedObjectPool<K, PoolablePreparedStatement<K>>)this.pStmtPool, this.delegatingConnection);
            return new DefaultPooledObject<DelegatingPreparedStatement>(pps);
        }
        final CallableStatement statement2 = (CallableStatement)key.createStatement(this.connection);
        final PoolableCallableStatement pcs = new PoolableCallableStatement(statement2, key, this.pStmtPool, (DelegatingConnection<Connection>)this.delegatingConnection);
        return new DefaultPooledObject<DelegatingPreparedStatement>(pcs);
    }
    
    protected String normalizeSQL(final String sql) {
        return sql.trim();
    }
    
    void notifyListeners() {
        final ConnectionEvent event = new ConnectionEvent(this);
        final Object[] arr$;
        final Object[] listeners = arr$ = this.eventListeners.toArray();
        for (final Object listener : arr$) {
            ((ConnectionEventListener)listener).connectionClosed(event);
        }
    }
    
    @Override
    public void passivateObject(final PStmtKey key, final PooledObject<DelegatingPreparedStatement> pooledObject) throws Exception {
        final DelegatingPreparedStatement dps = pooledObject.getObject();
        dps.clearParameters();
        dps.passivate();
    }
    
    CallableStatement prepareCall(final String sql) throws SQLException {
        if (this.pStmtPool == null) {
            return this.connection.prepareCall(sql);
        }
        try {
            return (CallableStatement)this.pStmtPool.borrowObject(this.createKey(sql, PoolingConnection.StatementType.CALLABLE_STATEMENT));
        }
        catch (final RuntimeException e) {
            throw e;
        }
        catch (final Exception e2) {
            throw new SQLException("Borrow prepareCall from pool failed", e2);
        }
    }
    
    CallableStatement prepareCall(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
        if (this.pStmtPool == null) {
            return this.connection.prepareCall(sql, resultSetType, resultSetConcurrency);
        }
        try {
            return (CallableStatement)this.pStmtPool.borrowObject(this.createKey(sql, resultSetType, resultSetConcurrency, PoolingConnection.StatementType.CALLABLE_STATEMENT));
        }
        catch (final RuntimeException e) {
            throw e;
        }
        catch (final Exception e2) {
            throw new SQLException("Borrow prepareCall from pool failed", e2);
        }
    }
    
    CallableStatement prepareCall(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
        if (this.pStmtPool == null) {
            return this.connection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
        }
        try {
            return (CallableStatement)this.pStmtPool.borrowObject(this.createKey(sql, resultSetType, resultSetConcurrency, resultSetHoldability, PoolingConnection.StatementType.CALLABLE_STATEMENT));
        }
        catch (final RuntimeException e) {
            throw e;
        }
        catch (final Exception e2) {
            throw new SQLException("Borrow prepareCall from pool failed", e2);
        }
    }
    
    PreparedStatement prepareStatement(final String sql) throws SQLException {
        if (this.pStmtPool == null) {
            return this.connection.prepareStatement(sql);
        }
        try {
            return this.pStmtPool.borrowObject(this.createKey(sql));
        }
        catch (final RuntimeException e) {
            throw e;
        }
        catch (final Exception e2) {
            throw new SQLException("Borrow prepareStatement from pool failed", e2);
        }
    }
    
    PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
        if (this.pStmtPool == null) {
            return this.connection.prepareStatement(sql, autoGeneratedKeys);
        }
        try {
            return this.pStmtPool.borrowObject(this.createKey(sql, autoGeneratedKeys));
        }
        catch (final RuntimeException e) {
            throw e;
        }
        catch (final Exception e2) {
            throw new SQLException("Borrow prepareStatement from pool failed", e2);
        }
    }
    
    PreparedStatement prepareStatement(final String sql, final int[] columnIndexes) throws SQLException {
        if (this.pStmtPool == null) {
            return this.connection.prepareStatement(sql, columnIndexes);
        }
        try {
            return this.pStmtPool.borrowObject(this.createKey(sql, columnIndexes));
        }
        catch (final RuntimeException e) {
            throw e;
        }
        catch (final Exception e2) {
            throw new SQLException("Borrow prepareStatement from pool failed", e2);
        }
    }
    
    PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
        if (this.pStmtPool == null) {
            return this.connection.prepareStatement(sql, resultSetType, resultSetConcurrency);
        }
        try {
            return this.pStmtPool.borrowObject(this.createKey(sql, resultSetType, resultSetConcurrency));
        }
        catch (final RuntimeException e) {
            throw e;
        }
        catch (final Exception e2) {
            throw new SQLException("Borrow prepareStatement from pool failed", e2);
        }
    }
    
    PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
        if (this.pStmtPool == null) {
            return this.connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
        }
        try {
            return this.pStmtPool.borrowObject(this.createKey(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
        }
        catch (final RuntimeException e) {
            throw e;
        }
        catch (final Exception e2) {
            throw new SQLException("Borrow prepareStatement from pool failed", e2);
        }
    }
    
    PreparedStatement prepareStatement(final String sql, final String[] columnNames) throws SQLException {
        if (this.pStmtPool == null) {
            return this.connection.prepareStatement(sql, columnNames);
        }
        try {
            return this.pStmtPool.borrowObject(this.createKey(sql, columnNames));
        }
        catch (final RuntimeException e) {
            throw e;
        }
        catch (final Exception e2) {
            throw new SQLException("Borrow prepareStatement from pool failed", e2);
        }
    }
    
    @Override
    public void removeConnectionEventListener(final ConnectionEventListener listener) {
        this.eventListeners.remove(listener);
    }
    
    @Override
    public void removeStatementEventListener(final StatementEventListener listener) {
        this.statementEventListeners.remove(listener);
    }
    
    public synchronized void setAccessToUnderlyingConnectionAllowed(final boolean allow) {
        this.accessToUnderlyingConnectionAllowed = allow;
    }
    
    public void setStatementPool(final KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> statementPool) {
        this.pStmtPool = statementPool;
    }
    
    @Override
    public boolean validateObject(final PStmtKey key, final PooledObject<DelegatingPreparedStatement> pooledObject) {
        return true;
    }
    
    @Override
    public synchronized String toString() {
        final StringBuilder builder = new StringBuilder(super.toString());
        builder.append("[connection=");
        builder.append(this.connection);
        builder.append(", delegatingConnection=");
        builder.append(this.delegatingConnection);
        builder.append(", logicalConnection=");
        builder.append(this.logicalConnection);
        builder.append(", eventListeners=");
        builder.append(this.eventListeners);
        builder.append(", statementEventListeners=");
        builder.append(this.statementEventListeners);
        builder.append(", closed=");
        builder.append(this.closed);
        builder.append(", pStmtPool=");
        builder.append(this.pStmtPool);
        builder.append(", accessToUnderlyingConnectionAllowed=");
        builder.append(this.accessToUnderlyingConnectionAllowed);
        builder.append("]");
        return builder.toString();
    }
}
