package org.apache.tomcat.dbcp.dbcp2;

import java.util.NoSuchElementException;
import java.sql.CallableStatement;
import org.apache.tomcat.dbcp.pool2.impl.DefaultPooledObject;
import java.sql.PreparedStatement;
import org.apache.tomcat.dbcp.pool2.DestroyMode;
import java.sql.SQLException;
import org.apache.tomcat.dbcp.pool2.PooledObject;
import org.apache.tomcat.dbcp.pool2.KeyedObjectPool;
import org.apache.tomcat.dbcp.pool2.KeyedPooledObjectFactory;
import java.sql.Connection;

public class PoolingConnection extends DelegatingConnection<Connection> implements KeyedPooledObjectFactory<PStmtKey, DelegatingPreparedStatement>
{
    private KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> pstmtPool;
    private boolean clearStatementPoolOnReturn;
    
    public PoolingConnection(final Connection connection) {
        super(connection);
    }
    
    @Override
    public void activateObject(final PStmtKey key, final PooledObject<DelegatingPreparedStatement> pooledObject) throws Exception {
        pooledObject.getObject().activate();
    }
    
    @Override
    public synchronized void close() throws SQLException {
        try {
            if (null != this.pstmtPool) {
                final KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> oldpool = this.pstmtPool;
                this.pstmtPool = null;
                try {
                    oldpool.close();
                }
                catch (final RuntimeException e) {
                    throw e;
                }
                catch (final Exception e2) {
                    throw new SQLException("Cannot close connection", e2);
                }
            }
        }
        finally {
            try {
                this.getDelegateInternal().close();
            }
            finally {
                this.setClosedInternal(true);
            }
        }
    }
    
    public void connectionReturnedToPool() throws SQLException {
        if (this.pstmtPool != null && this.clearStatementPoolOnReturn) {
            try {
                this.pstmtPool.clear();
            }
            catch (final Exception e) {
                throw new SQLException("Error clearing statement pool", e);
            }
        }
    }
    
    protected PStmtKey createKey(final String sql) {
        return new PStmtKey(this.normalizeSQL(sql), this.getCatalogOrNull(), this.getSchemaOrNull());
    }
    
    protected PStmtKey createKey(final String sql, final int[] columnIndexes) {
        return new PStmtKey(this.normalizeSQL(sql), this.getCatalogOrNull(), this.getSchemaOrNull(), columnIndexes);
    }
    
    protected PStmtKey createKey(final String sql, final int autoGeneratedKeys) {
        return new PStmtKey(this.normalizeSQL(sql), this.getCatalogOrNull(), this.getSchemaOrNull(), autoGeneratedKeys);
    }
    
    protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency) {
        return new PStmtKey(this.normalizeSQL(sql), this.getCatalogOrNull(), this.getSchemaOrNull(), resultSetType, resultSetConcurrency);
    }
    
    protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) {
        return new PStmtKey(this.normalizeSQL(sql), this.getCatalogOrNull(), this.getSchemaOrNull(), resultSetType, resultSetConcurrency, resultSetHoldability);
    }
    
    protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability, final StatementType statementType) {
        return new PStmtKey(this.normalizeSQL(sql), this.getCatalogOrNull(), this.getSchemaOrNull(), resultSetType, resultSetConcurrency, resultSetHoldability, statementType);
    }
    
    protected PStmtKey createKey(final String sql, final int resultSetType, final int resultSetConcurrency, final StatementType statementType) {
        return new PStmtKey(this.normalizeSQL(sql), this.getCatalogOrNull(), this.getSchemaOrNull(), resultSetType, resultSetConcurrency, statementType);
    }
    
    protected PStmtKey createKey(final String sql, final StatementType statementType) {
        return new PStmtKey(this.normalizeSQL(sql), this.getCatalogOrNull(), this.getSchemaOrNull(), statementType, null);
    }
    
    protected PStmtKey createKey(final String sql, final String[] columnNames) {
        return new PStmtKey(this.normalizeSQL(sql), this.getCatalogOrNull(), this.getSchemaOrNull(), columnNames);
    }
    
    @Override
    public void destroyObject(final PStmtKey key, final PooledObject<DelegatingPreparedStatement> pooledObject) throws Exception {
        pooledObject.getObject().getInnermostDelegate().close();
    }
    
    @Override
    public void destroyObject(final PStmtKey key, final PooledObject<DelegatingPreparedStatement> p, final DestroyMode mode) throws Exception {
        this.destroyObject(key, p);
    }
    
    private String getCatalogOrNull() {
        String catalog = null;
        try {
            catalog = this.getCatalog();
        }
        catch (final SQLException ex) {}
        return catalog;
    }
    
    private String getSchemaOrNull() {
        String schema = null;
        try {
            schema = this.getSchema();
        }
        catch (final SQLException ex) {}
        return schema;
    }
    
    public KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> getStatementPool() {
        return this.pstmtPool;
    }
    
    @Override
    public PooledObject<DelegatingPreparedStatement> makeObject(final PStmtKey key) throws Exception {
        if (null == key) {
            throw new IllegalArgumentException("Prepared statement key is null or invalid.");
        }
        if (key.getStmtType() == StatementType.PREPARED_STATEMENT) {
            final PreparedStatement statement = (PreparedStatement)key.createStatement(this.getDelegate());
            final PoolablePreparedStatement pps = new PoolablePreparedStatement(statement, (K)key, (KeyedObjectPool<K, PoolablePreparedStatement<K>>)this.pstmtPool, this);
            return new DefaultPooledObject<DelegatingPreparedStatement>(pps);
        }
        final CallableStatement statement2 = (CallableStatement)key.createStatement(this.getDelegate());
        final PoolableCallableStatement pcs = new PoolableCallableStatement(statement2, key, this.pstmtPool, this);
        return new DefaultPooledObject<DelegatingPreparedStatement>(pcs);
    }
    
    protected String normalizeSQL(final String sql) {
        return sql.trim();
    }
    
    @Override
    public void passivateObject(final PStmtKey key, final PooledObject<DelegatingPreparedStatement> pooledObject) throws Exception {
        final DelegatingPreparedStatement dps = pooledObject.getObject();
        dps.clearParameters();
        dps.passivate();
    }
    
    private CallableStatement prepareCall(final PStmtKey key) throws SQLException {
        return (CallableStatement)this.prepareStatement(key);
    }
    
    @Override
    public CallableStatement prepareCall(final String sql) throws SQLException {
        return this.prepareCall(this.createKey(sql, StatementType.CALLABLE_STATEMENT));
    }
    
    @Override
    public CallableStatement prepareCall(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
        return this.prepareCall(this.createKey(sql, resultSetType, resultSetConcurrency, StatementType.CALLABLE_STATEMENT));
    }
    
    @Override
    public CallableStatement prepareCall(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
        return this.prepareCall(this.createKey(sql, resultSetType, resultSetConcurrency, resultSetHoldability, StatementType.CALLABLE_STATEMENT));
    }
    
    private PreparedStatement prepareStatement(final PStmtKey key) throws SQLException {
        if (null == this.pstmtPool) {
            throw new SQLException("Statement pool is null - closed or invalid PoolingConnection.");
        }
        try {
            return this.pstmtPool.borrowObject(key);
        }
        catch (final NoSuchElementException e) {
            throw new SQLException("MaxOpenPreparedStatements limit reached", e);
        }
        catch (final RuntimeException e2) {
            throw e2;
        }
        catch (final Exception e3) {
            throw new SQLException("Borrow prepareStatement from pool failed", e3);
        }
    }
    
    @Override
    public PreparedStatement prepareStatement(final String sql) throws SQLException {
        return this.prepareStatement(this.createKey(sql));
    }
    
    @Override
    public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
        return this.prepareStatement(this.createKey(sql, autoGeneratedKeys));
    }
    
    @Override
    public PreparedStatement prepareStatement(final String sql, final int[] columnIndexes) throws SQLException {
        return this.prepareStatement(this.createKey(sql, columnIndexes));
    }
    
    @Override
    public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
        return this.prepareStatement(this.createKey(sql, resultSetType, resultSetConcurrency));
    }
    
    @Override
    public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
        return this.prepareStatement(this.createKey(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
    }
    
    @Override
    public PreparedStatement prepareStatement(final String sql, final String[] columnNames) throws SQLException {
        return this.prepareStatement(this.createKey(sql, columnNames));
    }
    
    public void setClearStatementPoolOnReturn(final boolean clearStatementPoolOnReturn) {
        this.clearStatementPoolOnReturn = clearStatementPoolOnReturn;
    }
    
    public void setStatementPool(final KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> pool) {
        this.pstmtPool = pool;
    }
    
    @Override
    public synchronized String toString() {
        if (this.pstmtPool != null) {
            return "PoolingConnection: " + this.pstmtPool.toString();
        }
        return "PoolingConnection: null";
    }
    
    @Override
    public boolean validateObject(final PStmtKey key, final PooledObject<DelegatingPreparedStatement> pooledObject) {
        return true;
    }
    
    public enum StatementType
    {
        CALLABLE_STATEMENT, 
        PREPARED_STATEMENT;
    }
}
